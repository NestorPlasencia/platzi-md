# Comprender qu√© es el lenguaje C

## 0010. Introducci√≥n al curso

### Descripci√≥n:


### Comentarios:

* **Juan Daniel Zaleta Turrubiates** (9)

	
	Hola! Ya que existe un curso de introducci√≥n a C deber√≠an hacer uno orientado a C pero programando PIC‚Äôs. Actualmente en la universidad empezamos a ver programaci√≥n de PIC‚Äôs y es bastante tedioso cuando no se tiene un buen mentor, pero Platzi siempre sabe c√≥mo hacer la ruta de aprendizaje divertida y digerible üòÉ

* **calozano8** (4)

	
	Vamos a con la mejor energ√≠a al encuentro de esta cita, esperamos sera un amor a primera vista.

* **Juan Antonio Oriza** (3)

	
	 **Lenguajes interpretados:** El programa se va traduciendo a lenguaje maquina en tiempo real, a medida que se va avanzando el programa en tiempo de ejecuci√≥n.
	
	**Lenguaje Compilado:** Se analiza el programa, se crea un binario y se procede a ejecutar.

* **Steven Angel Coaila Zaa** (3)

	
	A saciar la curiosidad otra vez!! üòÑ

* **wilantury** (3)

	
	Antes de conocer C, alcance a programar en assembler para microcontroladores de microchip y motorola, fu√© una √©poca dura.

* **Javier Alexander Almarza Bucarey** (3)

	
	Justo Ayer estaba buscando un curso de C en platzi

* **Maryori Sanjuanelo Boneu** (2)

	
	Desde hace mucho tiempo vengo usando foobar2000 como mi reproductor de audio y me parece una maravilla. Siempre he querido descifrarlo desde su c√≥digo y poder usarlo/modificarlo a nivel experto. Por supuesto, a este punto entiendo que est√° escrito en C++ y no C, pero es mi comienzo a cumplir este objetivo!

	* **Camilo Ignacio Acosta Acosta** (1)

		
		Que interesante proyecto. Espero que lo ejecutes y lo publiques en GitHub para aprender. Exitos.

	* **Maryori Sanjuanelo Boneu** (1)

		
		Muchas gracias Camilo! Estoy muy ansiosa por hacer este proyecto realidad y por supuesto compartir√© mis resultados. Saludos!

* **Manuel Mosquera** (2)

	
	Hac√≠a falta un curso de C. Que bueno !! Siempre me pareci√≥ que las personas que hab√≠an empezado con C ten√≠an muy buenas bases, ojal√° este curso tenga todo lo necesario.

* **gydoar** (2)

	
	Me imagino que Raspberry pi y Arduino usan C?

	* **Sammuel** (2)

		
		Asi es y tambi√©n Python

* **-Smiler-** (2)

	
	Justo empezamos a tomar tenemas relacionados al lenguaje C en la Universidad.

* **alexruizlul** (1)

	
	Considero que C es un lenguaje fundamental de aprender para cualquier programador, por la gran eficiencia que tiene.
	
	A darle con todo para aprenderlo bien. c:

* **Cristian Rosales** (1)

	
	Excelente introducci√≥n, empezamos con todo el animoü§òüèº

* **David Santiago Gonz√°lez Ramos** (1)

	
	Creo que C es un excelente lenguaje para aprender a programar. Puede que al inicio sea super dif√≠cil, pero desps de aprender C, aprender cualquier otro lenguaje, lo vas a hacer mucho m√°s f√°cil y r√°pido

* **Jean Carlos Nu√±ez Hernandez** (1)

	
	Vamos pues por C Languge

* **Joshua Hernandez** (1)
Cu√°l es la diferencia entre Int√©rprete, Compilador y Traductor?

	* **Jose Daniel Paiva** (1)

		
		Los **int√©rpretes** son los que ejecuta el c√≥digo sin realizar ninguna traducci√≥n.  
		Los **traductores** son los que transforman el c√≥digo a un lenguaje de bajo nivel y existen dos tipos ensambladores y **compiladores**.

* **Salvador Tapia Alvarez** (1)
Hola tienen una opci√≥n donde se puedan escuchar las clases en vez de verlas ?

	* **Manuel Rivera** (1)

		
		Algunos cursos que se encuentran disponibles solamente desde la app movil son 100% audio
		
		<https://platzi.com/clases/desbloquea-creatividad/>
		
		Pero si usas la app movil tambi√©n puedes escuchar las clases si deseas mientras te desplazas o realizas alguna otra actividad.  
		Por cierto el curso que te deje como enlace, es supremamente genial, saludos desde Colombia-Meta

## 0020. Herramientas para programar en C

### Descripci√≥n:


### Links:

* [Curso de Introducci√≥n a la Terminal y L√≠nea de comandos](https://platzi.com/clases/terminal/)

* [Code::Blocks -  Browse /Binaries/17.12/Windows at SourceForge.net](https://sourceforge.net/projects/codeblocks/files/Binaries/17.12/Windows/)

### Comentarios:

* **Lohana Mar√≠a Giraldo Sarria** (10)

	
	A continuaci√≥n les comparto una herramienta online donde es posible ejecutar y compilar sin instalar nada.  
	<https://www.onlinegdb.com/>

* **gydoar** (5)

	
	Que bien que uso Mac, no es necesario instalar un compilador pues ya viene por defecto.

	* **Mauro Chojrin** (6)

		
		Buen√≠simo! Eso sucede en general en todos los sistemas basados en Unix (Mac, Linux, BSD, etc‚Ä¶)

* **luis leonardo soto** (3)

	
	buen trabajo

* **AlexanderAReyes** (2)

	
	ready to programming

	* **paconity** (1)

		
		‚Äúready to programming‚Äù literalmente significa ‚Äúlisto para programando‚Äù, solo di ‚Äúready to program‚Äù.

	* **Franco Bottazzi** (2)

		
		paconity en realidad no, porque programming se puede interpretar como programaci√≥n

	* **paconity** (0)

		
		¬øFranco Bottazzi te gusta m√°s ‚Äúlisto para programaci√≥n‚Äù?

	* **Ricardo Quintana Soler** (2)

		
		ready to programming tambi√©n se puede traducir como listo para la programaci√≥n, s√≥lo que el uso de los art√≠culos en ingl√©s es distinto y muchas veces no se usan, mientras que en espa√±ol es necesario en muchos m√°s casos.

	* **AlexanderAReyes** (1)

		
		¬øY si mejor digo? prepared to encode

	* **Said Leonardo** (1)

		
		ready for programming*

	* **Oscar Grey** (1)

		
		No sean yankis  
		A tirar codigo

* **Vicnow** (2)

	
	M√°s rapido que un video de Youtube haha.

	* **Jorge Arango** (2)

		
		Seguro jajaja  
		Me hubiera ahorrado 2 horas de tutoriales si lo hubiera buscado primero aqu√≠

* **Jesus Diaz Castro** (1)

	
	INSTRUCCIONES  
	1 vas a SourceForge  
	2 En el buscador colocas Code::Blocks  
	3 Das click en Files  
	4 Das click en Binaries  
	5 Das click en la carpeta 17.12  
	6 Seleccionas la carpeta de tu sistema operativo  
	7 Descargas el archivo 17.12mingw-setup.exe

* **Manuel Mosquera** (1)

	
	Done !!

* **Jean Carlos Nu√±ez Hernandez** (1)

	
	Muy facil a instalacion, mi sistema base es Linux, por lo tanto viene con GCC por defecto

* **wilantury** (1)

	
	Instalando‚Ä¶

* **smarles** (1)
Importante la configuraci√≥n antes de utilizar el software En propiedades de Mi PC. Configuraci√≥n avanza...

# Aprender los conceptos iniciales del lenguaje C

## 0030. Compilaci√≥n y ejecuci√≥n de un programa en C

### Descripci√≥n:


### Comentarios:

* **Manuel Mosquera** (6)

	
	La compilaci√≥n tiene 4 pasos  
	1- Preproceso -E  
	2- Emsamblaje -S  
	3- Compilaci√≥n -C  
	4- Linkeo  
	Cuando ejecutamos la compilaci√≥n con la opci√≥n -o como en el ejemplo, ocurren estos 4 pasos primero, pero si queremos ver que pasa en cada paso podemos cambiar -o por alguna de las opciones que escrib√≠ anteriormente.

* **Jos√© Eduardo Reyes Yol** (3)

	
	No entend√≠ que fue lo que hizo, no tengo ni idea de la terminal de comandos. As√≠ que utilic√© GitBash y funcion√≥ jaja.

* **wilantury** (3)

	
	La terminal siempre ser√° una herramienta esencial en el proceso de desarrollo.

	* **Juan David Castro (Platzi)** (2)

		
		¬øCierto que s√≠? El profe Mauro tambi√©n es el profesor del Curso de Introducci√≥n a la Terminal: <https://platzi.com/clases/terminal/>. üòâ

	* **irwinmax** (1)

		
		juandc dice contenido no disponible :c

	* **Juan David Castro (Platzi)** (1)

		
		El curso est√° a punto de lanzarse. Si quieres ver la versi√≥n anterior puedes entrar aqu√≠: <https://platzi.com/clases/terminal-2019/>.

	* **AlexanderAReyes** (1)

		
		totalmente de acuerdo

* **calozano8** (3)

	```
	    # include<stdio.h>
	    intmain(){
	    	printf("Hola mundo! \n");
	    	return0;
	    
	    }
	    
	```

* **Cristian Rosales** (2)

	
	[Aqu√≠](https://victorhck.gitlab.io/comandos_vim/articulos.html) pueden encontrar muchos comandos y tutoriales para potenciar Vim.

* **predator0077** (2)

	
	Pues Vamos a Darle, a fortalecer mis conocimientos en C.

* **Camilo Ignacio Acosta Acosta** (1)

	
	Hola todos. Esto te puede servir.  
	Intente de todas las maneras ejecutar el archivo compilado. Es decir se generaba pero luego me dec√≠a acceso denegado. Luego me di cuenta que el archivo ejecutable se crea pero luego desaparec√≠a y yo un poco con cara de ‚ÄúAlgo anda mal‚Äù. Resulta que despu√©s de un buen rato me di cuenta que era culpa de mi antivirus que identificaba al ejecutable como una amenaza. Nota al ejecutar desactiven el antivirus.

* **Cristian Rosales** (1)

	
	En caso de que nos les funcione el comando gcc en la terminal de Ubuntu pueden hacer [esto ](https://linuxize.com/post/how-to-install-gcc-compiler-on-ubuntu-18-04/)para resolverlo (A mi me funciono).

* **Jean Carlos Nu√±ez Hernandez** (1)

	
	Muy facil la compilacion con Clang

* **kevin-isaac** (1)

	
	 _Como compilar en C:_
	
	**Opci√≥n 1** asignarle el nombre al archivo ejecutable:  
	$ gcc Nombre_Del_Archivo**.c** -o Nombre_del_archivo_ejecutable
	
	**Opci√≥n 2** no asignarle nombre al archivo ejecutable:  
	$ gcc Nombre_Del_Archivo.c  
	Si solo ejecutamos este comando en la terminal nos dar√° un nombre por defecto a nuestro archivo ejecutable, en mi caso a mi me da un archivo de nombre ‚Äòa.out‚Äô
	
	_Como ejecutar en C:_
	``` 
	    $	**./**   Nombre_del_ArchivoEjecutable
	    
	```
	
	ejemplo:  
	$ **./** a.out

* **Jesus Diaz Castro** (1)
No entend√≠ , Despu√©s de escribir el codigo en donde ejecuta el codgio gcc helloworld.c -o helloworld ? en el editor de texto?

	* **jose luis gonzalez aguilera** (2)

		
		hola, si tienes windows 10 descarga el programa ‚ÄúUbuntu 18.04 LTS‚Äù del store de windows 10 ah√≠ vas a poder ejecutar el comando gcc. si te da error al instalar la aplicacion de ubuntu en el mismo error de va a dar un link a un post de ayuda solo sigue la instrucciones y vas a poder instalar el programa.

* **Omar Garrido Garc√≠a** (1)
en mi terminal de ubuntu me me dice que gcc no esta instalado y segui los pasos del otro video, alguien sabr√≠a porque pasa esto?

	* **Kevin Javier Morales (Platzi)** (2)

		
		mu√©stranos que error te da para poder ayudarte mejor

* **Juan Felipe Turca Molina** (1)
hola, veo que en el minuto 1:50 luego de que pone la ultima llave, ¬øque es lo que hace para guardarlo? que bot√≥n oprime o que es lo que ...

	* **Massimo Di Berardino** (5)

		
		Hola Felipe, ahi lo que hace luego que escribe el codigo, [esc] para salir del modo escritura de la terminal vim y luego coloca [:x] esto lo que hace es guardar el archivo creado y salir del editor vim, [aca](https://www.tecmint.com/save-file-in-vi-vim-editor-in-linux/) te dejo un link donde se explica muy claramente como usar el editor vim. saludos!

## 0040. Tipos de datos

### Descripci√≥n:


### Comentarios:

* **Danelia Sanchez Sanchez** (6)

	
	[Operadores Bit a Bit](https://www.programiz.com/c-programming/bitwise-operators)

* **wilantury** (4)

	
	La comilla simple se usa para caracteres y la comilla doble se usa para cadenas de caracteres.

* **gydoar** (3)

	
	Datos num√©ricos: int, float  
	Datos alfanum√©ricos: char, strings

* **Josue12** (2)

	
	Interesante lo de los tipos de dato bit a bit, nunca los hab√≠a escuchado

	* **Jeffersson Mu√±oz Torres** (2)

		
		Si deseas ahondar un poco mas sobre ellos, puedes buscar sobre **_Algebra Boolena_**.

	* **Franco Bottazzi** (5)

		
		Te los explico de una forma r√°pida:  
		Los operadores bit a bit, como ya escuchaste, operan sobre cadenas de bits. Como a los bits es facil pensarlos como booleanos (porque un bit 0 ser√≠a lo mismo que falso y un 1 es verdadero), se puede realizar operaciones l√≥gicas (not, and, or, xor) sobre ellos.  
		Para usar el ej. del v√≠deo, el 42 y el 215 se pueden expresar en binario con 8 bits (o un Byte), lo que da 42 = 00101010 y 215 = 11010111. Entonces, el and bit a bit agarra el primer bit de cada uno y el and de esos dos es el primer bit del resultado. As√≠ hace con el segundo, tercero, etc. Entonces, por ejemplo, el bit de m√°s a la derecha de 42 es 0, y el del 215 es 1, entonces el bit de m√°s a la derecha del resultado es 0 and 1 = 0 (porque false && true es false)

* **Manuel Mosquera** (2)

	
	Un string es a su vez un array que est√° conformado por elementos tipo char.

* **Francisco Tassone** (2)

	
	bueno creo que falt√≥ decir, que lo que sucede es que se hace una operaci√≥n AND, bit a bit, con lo cual el ‚Äúapagar un bit‚Äù por as√≠ decirlo, se da tambi√©n en los casos de los bits 6 , 7 , 4 , 2 y 0 , esto enfoc√°ndonos en el valor 42.  
	Esto tambi√©n de lo conoce funci√≥n AND con m√°scara (seg√∫n en cual operando nos paremos, podremos decir m√°scara AND con 42 o m√°scara AND con 215). Se usa mucho en el lenguaje para microcontroladores, para validar bits, por ejemplo en un hardware donde haya entradas digitales conectadas a X sensores.

* **Jean Carlos Nu√±ez Hernandez** (1)

	
	Todos lo diferente de Cero 0 es verdadero y si es cero es falso para los booleanos

## 0050. Definici√≥n de variables

### Descripci√≥n:


### Comentarios:

* **Mario E Fernandez  Serrano** (5)

	
	Mis primeras l√≠neas de c√≥digo en C üòÉ
	``` 
	    #include<stdio.h>
	    
	    intmain()
	    {
	      printf ("Hola COVID-19 Bienvenido a la especie Humana\n");
	      return0;
	    }
	    
	```

* **onyx** (4)

	
	es importante recalcar que hay variaciones en el comportamiento del sistema unario, ya que:
	``` 
	    int main(void)
	    {
	    	// Fijamos el valor de "a" en "1"
	    	int a = 1;
	    	// En este caso "b" primero tomara el valor de "a"
	    	// Quedando asi que el valor de "b" es "1"
	    	// Y luego a aumenta su valor en uno
	    	// Quedando asi que el valor de "a" es "a + 1" que es igual a "2"
	    	int b = a++;
	    	// En este caso primero "a" aumenta su valor
	    	// Asi queda que "a" es "a + 1" que seria "3"
	    	// Luego asigna este nuevo valor de "a" en "c"
	    	// Quedando que el valor de "c" es "3"
	    	int c = ++a;
	    	// Entonces
	    	// a = 3
	    	// b = 1
	    	// c = 3
	    }
	    
	```

* **wilantury** (4)

	
	Operadores unarios: a++, a‚Äì, a+=, a-=, a*=, a/=. Se usan frecuentemente en el lenguaje C.

* **calozano8** (4)

	```
	    #include<stdio.h>
	    intmain()
	    {
	        char nombre[20];
	        int edad;
	        //Pedimos el nombre del usuario
	        printf("Digite su nombre :  ");
	    
	        //Almacenamos el nombre en la variable nombre
	    
	        scanf("%s", nombre);
	    
	        // Pedimos la Edad del usuario
	    
	        printf("Digite su edad :  ");
	        // Almacenamos la edad del usuario
	        scanf("%d", &edad);
	    
	        // Mostramos en pantalla lo datos suministrados
	        printf("\nWelcome  : %s ", nombre);
	        printf("\nSu edad es : %d ", edad );
	        printf("\n");
	        return0;
	    
	        /**Desarrollador: Carlos lozano**/
	    }
	    
	```

* **Lery Andy Pi√©rola Lazarte** (2)
En que casos seria indispensable usar el lenguaje C?

	* **darwabo** (2)

		
		Sistemas en tiempo real ,es decir sistemas en la que se necesita que la respuesta sea inmediata

* **EPadronU23** (1)

	
	Extra√±aba hacer este tipo de tonter√≠as:
	``` 
	    #include<stdio.h>
	    #include<stdlib.h>
	    
	    intmain(int argc, char *argv[])
	    {
	      unsignedshort myShort = 0x09AF;
	      char *shortBytes = &myShort;
	    
	      unsignedint myInt = 0x0099AAFF;
	      char *intBytes = &myInt;
	    
	      printf("Short:\t%02x %02x\n", shortBytes[0] & 0xff, shortBytes[1] & 0xff);
	    
	      printf("Int:\t%02x %02x %02x %02x\n", intBytes[0] & 0xff, intBytes[1] & 0xff, intBytes[2] & 0xff, intBytes[3] & 0xff);
	    
	      return0;
	    }
	    
	```
	``` 
	    Short:	af 09
	    Int:	ff aa 9900
	    
	```
	
	Muestra byte a byte el contenido de un short y de un int. (Se muestra de atr√°s para adelante porque mi m√°quina es [little-endian](https://en.wikipedia.org/wiki/Endianness))

	* **Josue12** (2)

		
		No entend√≠ al 100% tu c√≥digo, pero maso menos se que hace jaja; me podr√≠as explicar para que es el %02x ? y por que que shortbytes y intBytes se tratan como si fueran un array (shottbyte[1],intbytes[0], ect)?

	* **EPadronU23** (2)

		
		Ser√° un placer @josue12
		
		Me estoy aprovechando de la flexibilidad del lenguaje para acceder a fragmentos de un _unsigned short_ y de un _unsigned int_.
		
		Normalmente un `char` se representa con **1** byte, un `short` con **2** bytes y un `int` con **4** bytes.
		
		Estoy _apuntando_ los punteros _shortBytes_ y _intBytes_ a la direcci√≥n de memoria donde se encuentran almacenados _myShort_ y _myInt_ , respectivamente. Al acceder a esas celdas de memoria de **1 en 1 byte** (tratarlas como un puntero/arreglo a `char`), puedo mostrar el contenido de esos bytes de manera independiente.
		
		`%02x` me permite mostrar al menos 2 d√≠gitos hexa-decimales, rellenando con 0 en caso de haber solo uno (0F en lugar de F).
		
		Con `intBytes[0] & 0xff` aplico una m√°scara a nivel de bits para solo mostrar 2 d√≠gitos hexa-decimales (de lo contrario `%x` mostrar√≠a siempre 4).
		
		Espero haya quedado un poco m√°s claro.
		
		Luego de terminar el curso, puedes volver a este c√≥digo y determinar si ya le terminas de dar sentido al asunto. Caso contrario, me puedes contactar nuevamente.

* **Manuel Mosquera** (1)

	
	Es importante saber el tipo de dato de nuestra variable para as√≠ mismo asignarle lo que queremos y evitar errores.

* **jhayro-guerrero** (1)

	
	Si se dan cuenta que no concuerda el contenido de la app con la de la web, la web me dice que aprenda C pero en la app te ofrece C++, cual se debe tomar para efectos de estudio.

	* **Josue12** (1)

		
		Ambos son muy similares

* **Jean Carlos Nu√±ez Hernandez** (1)

	
	Los operadores binarios son todos aquello que tiene un unico operando y este operado es una variable

* **Jean Carlos Nu√±ez Hernandez** (1)

	
	Una variable es un lugar en donde podemos almacenar datos

* **Federico Ivan Llano** (0)

	
	hay una sola cosa que no entiendo, como esta usando la terminal, ubuntu y el editor.  
	Aprendi primero C# el a√±o pasado, sigo en platzi la ruta de fundamentos de programacion, pense que se podia usar visual studio como editor, pero ahora estoy usando de editor el programa CodeBlocks y la consola.  
	No se si mas adelante me va a seguir sirviendo. Pero bueno habia leido un libro hace bastante sobre la sintaxis de C asi que voy entendiendo lo basico.

## 0060. Control de flujos

### Descripci√≥n:


### Links:

* [platzi-curso-c/if.c at master ¬∑ mchojrin/platzi-curso-c ¬∑ GitHub](https://github.com/mchojrin/platzi-curso-c/blob/master/if.c)

* [platzi-curso-c/switch.c at master ¬∑ mchojrin/platzi-curso-c ¬∑ GitHub](https://github.com/mchojrin/platzi-curso-c/blob/master/switch.c)

* [platzi-curso-c/while.c at master ¬∑ mchojrin/platzi-curso-c ¬∑ GitHub](https://github.com/mchojrin/platzi-curso-c/blob/master/while.c)

* [platzi-curso-c/do_while.c at master ¬∑ mchojrin/platzi-curso-c ¬∑ GitHub](https://github.com/mchojrin/platzi-curso-c/blob/master/do_while.c)

* [platzi-curso-c/for.c at master ¬∑ mchojrin/platzi-curso-c ¬∑ GitHub](https://github.com/mchojrin/platzi-curso-c/blob/master/for.c)

### Comentarios:

* **wilantury** (5)

	
	Estructuras condicionales: if, switch.  
	Estructuras repetitivas: while(){}, do{}while().  
	Estructura repetitiva definida: for(){}

* **David Felipe Boh√≥rquez** (4)

	
	Me pareci√≥ excelente la forma de explicar las repetitivas 0 -X y 1 -X. Mucho m√°s claro que con otros profes.

	* **Mauro Chojrin** (4)

		
		Gracias!!

* **Juan Antonio Oriza** (3)

	
	  * **Control de flujo** : Define como se mueven los datos a trav√©s de nuestros programas. Tenemos estructuras de flujo condicionales y estructuras repetitivas.
	
	  * La estructura **while** es 0-x, es decir no se ejecuta al menos que se cumpla la condici√≥n especificada.
	
	  * La estructura **do-while** es 1-x, es decir se ejecuta al menos una vez.
	
	  * La estructura **for** se utiliza cuando sabemos de antemano cuantas veces queremos que se ejecute el ciclo.
	
	
	

* **JanethM** (2)

	```
	    // Control de flujos - Condicionales
	    // **IF**
	    int main()
	    {
	        //un igual es operador de asignacion
	    	int a =1;
	    
	        // dos iguales es operador de comparacion
	    	if(a==1){
	    		a=2;
	    	}else{
	    		a=3;
	    	}
	    }
	    
	    // **SWITCH**
	    int main()
	    {
	        int a =1;
	    
	        switch(a){
	            case1:
	                a=10;
	                break;
	            case2:
	                a=20;
	                break;
	            case3:
	                a=30;
	                break;
	            default:
	                a=100;
	                break;
	        }
	    }
	    
	    // Control de flujo - repetitivos
	    // **0-X WHILE**
	    int main()
	    {
	        int n = 1, acum = 10;
	    
	        while(acum <10){
	            acum =+ n;
	            n++;
	        }
	    
	        return acum;
	    }
	    
	    // **1-X DO WHILE**
	    int main()
	    {
	        int n=1, acum=10;
	    
	        do{
	            acum += n;
	            n++;
	        }while(acum < 10);
	    
	        return acum;
	    }
	    
	    // Repetitivas definidas
	    // **FOR**
	    int main()
	    {
	        int i, acum = 0;
	        for (i = 0; i < 10; i++)
	        {
	            acum += i;
	        }
	        return acum;    
	    }
	    
	```

* **Jean Carlos Nu√±ez Hernandez** (2)

	
	Son faciles los controles de flujo, aprendi rapido

	* **Josue12** (1)

		
		Concuerdo

* **Alejandro Seraf√≠n Guti√©rrez** (1)

	
	En ning√∫n momento ‚Äúacum‚Äù val√≠a menor que 10 porque se declaro como 10 al inicio por lo tanto el while al hacer la validaci√≥n se salto hasta la instrucci√≥n ‚Äúreturn‚Äù.

	* **bcanon** (1)

		
		Exacto el ejemplo de while no fue bien implementado para ver su funcionalidad.

* **Johan Lisandro Castiblanco** (1)

	
	Re bien Mauro , me gustan tus clases. Explicas como para entender que se hace en cada caso y para que =)

* **JAVIER STIVEN MURILLO CORREA** (1)

	
	== no es igual a =

* **David Santiago Gonz√°lez Ramos** (1)

	
	 _Condicionales_ :
	
	  * If (condition) {instructions}
	  * switch (variable) {case [constant]:instructions}
	
	
	
	_Ciclos_
	
	  * for (init, condition, change) {instructions}
	  * while (condition) {instructions; change}
	
	

* **Manuel Mosquera** (1)

	
	Es m√°s com√∫n escuchar ciclos y no repetitivas.

* **Maryori Sanjuanelo Boneu** (1)
Hola, necesito ayuda!!! Cuando intento correr el archivo ejecutable en la linea de comando no me arroja el resultado. En cambio, el progr...

	* **Josemanuel Sifontes** (2)

		
		intenta con no pasar el archivo a un .exe, y deja el archivo sin extensi√≥n.  
		y luego de que lo compiles usa escribe en la linea de comandos el nombre del archivo con ‚Äú./‚Äù.  
		Ejemplo:  
		./function  
		./helloworld

* **Nicolas David Pastran Zamora** (0)
¬øEl switch funciona para evaluar √∫nicamente el comparador ‚Äò==‚Äô?, o tambi√©n se puede evaluar si algo es menor o igual.

	* **Kevin Javier Morales (Platzi)** (1)

		
		S√≠, tambi√©n puede usarse para ese y todos los dem√°s tipos de operadores l√≥gicos.

## 0070. Uso y definici√≥n de funciones

### Descripci√≥n:


### Comentarios:

* **EPadronU23** (3)

	
	Con todo respeto: **C** en efecto cuenta con _procedimientos_. Toda rutina que define su _tipo de retorno_ como `void` se considera un **_procedimiento_**. Es debido a eso que **C** es un lenguaje _procedural_ (orientado a procedimientos).
	
	[Procedures (subroutines not returning values) are a special case of function, with an untyped return type void.](https://en.wikipedia.org/wiki/C_\(programming_language\)#Overview)

* **Juan Antonio Oriza** (3)

	
	 **Para los que est√©n usando el CMD de windows:**
	
	  * En el shell de linux, el comando que usa el prof **$?** devuele el estado de salida del √∫ltimo comando ejecutado (exit status of the last executed command).
	
	  * Un comando equivalente en CMD es **ECHO %ERRORLEVEL%**
	
	
	

* **Josue12** (2)

	
	Aqui hablan un poco mas a fondo de las funciones en c.  
	<http://programandoenc.over-blog.es/article-32481588.html>

* **Josue12** (2)

	
	Le falto hablar mas sobre las funciones

* **JanethM** (1)

	```
	    // Funcion f
	    // que recibira un argumento de tipo entero
	    // y internamente en la funcion se conocera como a
	    intf(int a){
	        return a * 2;
	    }
	    // Funcion main
	    intmain(){
	        return f(5);
	    }
	    
	    //Resultado esperado 10
	    
	```

* **Jean Carlos Nu√±ez Hernandez** (1)

	
	la funcion main si devuelve un numero todo salio bien sino hubo algun problema

* **Jean Carlos Nu√±ez Hernandez** (1)

	
	Rutinas -> peque√±os pedacitos de codigo que son reutilizable

## 0080. Directivas de pre-compilador

### Descripci√≥n:


### Comentarios:

* **Juan Antonio Oriza** (5)

	
	 **PlaceHolders o Especificadores de Conversi√≥n (Format Specifier), del lenguaje C**
	
	![images.jpg](https://static.platzi.com/media/user_upload/images-7294d314-a5f4-4973-9c0d-632da4b9450c.jpg)

* **Juan Antonio Oriza** (3)

	
	  * Las directivas del prepocesador empiezan con **#**
	
	  * En el caso de **#include <algo>** indican al compilador que se va a incluir otro archivo antes de empezar el proceso de compilaci√≥n.
	
	  * El preprocesador es el primer programa que invoca el compilador de C antes de empezar a traducir el c√≥digo a lenguaje m√°quina.
	
	
	

* **carlosguzman** (3)

	
	El reto‚Ä¶
	
	![reto-1.PNG](https://static.platzi.com/media/user_upload/reto-1-1ade306a-b48a-422f-85ea-d5023b8da463.jpg) ![reto-2.PNG](https://static.platzi.com/media/user_upload/reto-2-df816e40-fcfa-4c13-a583-6840b6e9f36b.jpg)

* **guillermogranado** (3)

	```
	    #include <stdio.h>
	    
	    int square(int num) {
	        return num * num;
	    }
	    
	    int main() {
	        int num = 5;
	        intresult = square(num);
	        printf("Square of %d is %d\n", num, result);
	        returnresult;
	    }
	    
	```

* **Brayan Potosi Dominguez** (2)

	
	**Mi codigo** üòÉ
	``` 
	    #include<stdio.h>
	    
	    int main(){
	    	
	    	int primerNumero, segundoNumero, suma;
	    	
	    	
	    	printf("Digita el primer numero a sumar : ");
	    	scanf("%d", &primerNumero);
	    	
	    	printf("\nDigita el segundo numero a sumar : ");
	    	scanf("%d", &segundoNumero);
	    	
	    	suma = primerNumero + segundoNumero;
	    	
	    	printf("\nEl resultado para la suma de %d %s %d %s %d",primerNumero,"y" ,segundoNumero," es : " ,suma);
	    	
	    	
	    	return0;
	    	
	    }
	    
	```

* **Daniel Esteban Santos Mendez** (2)

	
	Les comparte mi codigo del reto, es sencillo, da el doble de cualquiera n√∫mero.
	``` 
	    #include<stdio.h>
	     intf(int n)
	    {
	            return n * 2;
	    }
	    
	    
	    intmain()
	    {
	            int num;
	    
	            printf("El doble de un n√∫mero, pon cualquiera num:  \n");
	            scanf("%i", &num);
	    
	            int resultado = f(num);
	    
	            printf("El doble es: %i\n", resultado); 
	            return0;
	    
	    }
	    
	```

* **EPadronU23** (2)

	
	Se habl√≥ casi nada de las directivas de pre-procesamiento.  
	-1

* **FrcGustavo** (2)

	
	Reto 1 listo un programa que calcula tu peso en otro planeta
	``` 
	    #include <stdio.h>
	    #include <stdlib.h>
	    
	    double calc_weight(double weight, double gravity);
	    void menu();
	    
	    int main() {
	      int opc;
	      double weight = 0;
	      double JUPITER = 24.79;
	      double MARS = 3.711;
	      double result;
	    
	      printf("Please enter your weight: ");
	      scanf("%lf", &weight);
	      do {
	        menu();
	        scanf("%i", &opc);
	    
	        switch (opc) {
	          case1:
	            result = calc_weight(weight, MARS);
	            break;
	          case2:
	            result = calc_weight(weight, JUPITER);
	            break;
	          default:
	            opc = 0;
	            break;
	        }
	    
	        system("clear");
	        if(opc != 0) {
	          printf("Your weight is: %lf kg\n\n", result);
	        } else {
	          printf("Bye!\n");
	        }
	    
	      } while (opc != 0);
	      
	    }
	    
	    double calc_weight(double weight, double gravity) {
	      double result;
	      result = (weight / 9.81) * gravity;
	      returnresult;
	    }
	    
	    void menu() {
	      printf("Bienvenido a calcula tu peso en otro planeta\n");
	      printf("\t\t1 = Mars\n");
	      printf("\t\t2 = Jupiter\n");
	      printf("\t\t3 = Exit\n");
	      printf("Select opction: ");
	    }
	    
	```

* **onyx** (2)

	
	el reto :V
	``` 
	    #include<stdio.h>
	    
	    intmain(void)
	    {
	    	int a = 4, b = 7;
	    
	    	printf("El calculo de %d + %d es igual a %d", a, b, a + b);
	    
	    	return0;
	    }
	    
	```

* **Juan Daniel Zaleta Turrubiates** (2)

	
	Les comparto como lo hago en VS code. Asi puedo editar con la asistencia de VS Code mientras ejecuto el programa con la consola del mismo IDE
	
	![Captura de Pantalla 2019-11-29 a la\(s\) 1.14.19 p.¬†m..png](https://static.platzi.com/media/user_upload/Captura%20de%20Pantalla%202019-11-29%20a%20la%28s%29%201.14.19%20p.%C2%A0m.-53a51eb1-0262-4d3f-953c-f5635cfd5279.jpg)

* **juanjosejaramillo** (2)

	```
	    #include <stdio.h>
	    
	    int main () {
	            int a = 10;
	            int b = 5;
	            int c = a + b;
	            printf("La suma de %d y %d es: %d",a,b,c );
	            return0;
	    }
	    
	```

* **Walter Barrios Vazquez** (2)

	```
	    #include<stdio.h>
	    
	    intcuadrado( int num )
	    {
	    	return num * num;
	    }
	    
	    intmain()
	    {
	    	int num = 5;
	    	
	    	printf("El cuadrado de %d es: %d.\n", num, cuadrado(num) );
	    
	    	return cuadrado( num );
	    }
	    
	```

* **Erick Lopez** (1)

	
	programa sencillo que realiza problemas aritmeticos
	``` 
	    #include <stdio.h>
	    
	    // funcion calculo aritmetico
	    void calculo(int opcion_Digitado)
	    {
	    	// variables para la operacion aritmetica
	    	float x, y;
	    	//pidiendo los valores 
	    	printf("\t\n Digite el primer numero: ");
	    	scanf("%f",&x);
	    	printf("\t\n Digite el segundo numero: ");
	    	scanf("%f",&y);
	    	// realizando operacion segun sea el caso
	    	switch(opcion_Digitado)	
	    	{
	    	case1:	
	    		x += y;
	    		printf("\t\n\nLa suma es : %.2f\n\n",x);
	    		break;
	    	case2:	
	    		x -= y;
	    		printf("\t\n\nLa resta es : %.2f\n\n",x);
	    		break;
	    	case3:	
	    		x *= y;
	    		printf("\t\n\nLa multiplicacion es : %.2f\n\n",x);
	    		break;
	    	case4:	
	    		x /= y;
	    		printf("\t\n\nLa division es : %.2f\n\n",x);
	    		break;
	    	}	
	    }
	    
	    
	    int main()
	    {
	    	int opcion = 0; //declarando la opcion del menu
	    	//menu
	    	do
	    	{
	    		printf("\tPrograma que realiza operaciones Aritmeticas\n ");
	    		printf("\t 1 Suma \n");
	    		printf("\t 2 Resta \n");
	    		printf("\t 3 Multiplicaion \n");
	    		printf("\t 4 Division \n");
	    		scanf("\t %d", &opcion);
	    	}
	    
	    	while(opcion < 1 || opcion > 4);
	    	// funcion de calculo
	    	calculo(opcion);
	    
	    	return0;
	    }
	    
	    
	```

* **Carlos Augusto P√©rez M√©ndez** (1)

	```
	    #include <stdio.h>
	    #include <stdlib.h>
	    
	    
	    
	    
	    
	    
	    
	    
	    floatMillimeters_to_Meters (floatMillimeters_Value)    //To convert millimeter to meters.
	    {
	    	
	            scanf ("%f", &Millimeters_Value);
	    
	    	returnMillimeters_Value / 1000;
	    	
	    }
	    
	    floatMeters_to_Millimeters (floatMeters)       //To convert meter to millimeters.
	    {   
	    	scanf("%f", &Meters);
	    	returnMeters * 1000.0;
	    }
	    
	    
	    floatCentimeters_to_Meters (floatCentimeters)  //To convert centimeter to meters.
	    
	    {
	           scanf ("%f", &Centimeters);
	           
	           returnCentimeters / 100.0;
	    }
	    
	    
	    
	    int main ()
	    {
	    	floatUnit_centimeters = 0.0, Unit_Meters = 0.0,Unit_Millimeters = 0.0, Millimeters_Value = 0.0, Meters_Value = 0.0, Centimeters_Value = 0.0, result;
	            intMenu_Options = 0;
	            
	    	printf ("****************************\n");
	            printf ("WELCOME TO MENU OPTIONS\n");
	    	printf ("****************************\n"); 
	    	printf ("Select an option from Menu [1-3]\n");
	    	printf ("1. Centimeters.\n");
	    	printf ("2. Millimeters.\n");
	    	printf ("3. Meters.\n");
	    
	            scanf ("%d", &Menu_Options);
	    
	             switch (Menu_Options) 
	    	 {
	    		 case1:
	    			
	    		         result = Centimeters_to_Meters (Centimeters_Value);
	    			 printf ("%1.2f\n", result);
	    			 break;
	                     case2:
	    			 
	    			 result = Millimeters_to_Meters (Millimeters_Value);
	    			
	    		         printf("%1.2f\n", result);
	    			 
	    			 break;
	    			 
	    			 
	    			
	    	         case3: 
	    			 
	    			 result = Meters_to_Millimeters (Meters_Value);
	    			 printf ("%1.2f", result);
	    			 break;
	    
	    		 default:
	    			 printf ("ERROR! THE OPTION SELECTED DOES NOT EXIST, TRY AGAIN WITH OTHER OPTION\n");
	    	 }	 
	          
	    }
	    
	```

	* **Carlos Augusto P√©rez M√©ndez** (1)

		
		Un peque√±o programa para convertir algunas unidades de medida a otra  
		Metros a milimetros  
		Milimetros a metro  
		Centimetro a metro
		
		![](url)![menu.JPG](https://static.platzi.com/media/user_upload/menu-e7951109-5326-497b-a1e5-ed18726f3ccd.jpg)

* **Nicolas David Pastran Zamora** (1)

	
	Estas sentencias son muy utilices para programar micro controladores ya que que el mismo programa nos puede servir para diferentes dispositivos sin importar que sus registros se configuren ligeramente diferente. Ejemplo configuraci√≥n de osciladores para diferentes pic.
	``` 
	    #ifdef _18F2550
	        OSCCON=0x73; 
	        while(!IOFS); 
	    #endif
	    #ifdef _16F1769
	        OSCCON=0x70;    
	        while(!HFIOFS); 
	    #endif
	    
	```

* **Jos√© Eduardo Reyes Yol** (1)

	
	Despu√©s de probar, funciona. Aunque en esta clase casi no se hablo de las directivas de pre-compilador.
	``` 
	    #include <stdio.h>
	    
	    int main (){
	        printf("Coloca un primer n√∫mero");
	        int a;
	        scanf("%i", &a);
	        printf("Coloca un segundo n√∫mero");
	        int b;
	        scanf("%i", &b);
	        int res = a + b;
	        printf ("La suma de %d y %d es %d", a, b, res);
	        return0;
	    }
	    
	```

* **Luis Santoy** (1)

	
	![](![operations.jpg](https://static.platzi.com/media/user_upload/operations-e2a762e2-5e86-4a60-bdd2-0ea49de64edc.jpg)

* **gberruet** (1)

	```
	    #include<stdio.h>
	    
	    intf(int a, int b){
	    	return a + b;
	    }
	    
	    intmain(){
	    	int num1 = 5;
	    	int num2 = 7;
	    	int suma = f(num1,num2);
	    	printf("El resultado de la suma entre %d y %d es: %d\n",num1, num2, suma);
	    }
	    
	```

* **EPadronU23** (1)

	```
	    #include<stdio.h>
	    #include<stdlib.h>
	    
	    unsignedlongiterativeFibonacci(unsignedlong nth){
	      unsignedlong n1 = 1;
	      unsignedlong n2 = 0;
	    
	      nth--; // Compensates for 0 being the first Fibonacci number
	    
	      for(unsignedlong aux = 0; nth > 0U; nth--) {
	        aux = n2;
	        n2 = n1;
	        n1 += aux;
	      }
	    
	      return n2;
	    }
	    
	    intmain(){
	      unsignedlong nth = 0;
	    
	      printf("Introduce the -nth Fibonacci number you want to get: ");
	      scanf("%lu", &nth);
	    
	      if (nth == 0) {
	        fprintf(stderr, "Only numbers greater than or equal to 1 are valid ordinals\n");
	        exit(1);
	      }
	    
	      printf("The %lu-th Fibonacci number is %lu", nth, iterativeFibonacci(nth));
	    
	      return0;
	    }
	    
	```

* **Luis_Cruz_Cruz** (1)

	
	Hola a todos,
	
	Les comparto el codigo que realic√© para el reto de est clase. Espero que este codigo les sea util.
	
	Cualquier duda o comentario con respecto a este tema ser√° bienvenido.
	``` 
	    /*Challenge 1: Convert polar to rectangular coordinates */
	    
	    #include<stdio.h>
	    #include<math.h>
	    #include<stdlib.h>
	    
	    floatdeg_rad(float angle)
	    {
	    	return angle * (3.1416/180);
	    }
	    
	    floatx_comp(float theta, float radius)
	    {
	    	returnradius*cos(theta);
	    }
	    
	    floaty_comp(float theta, float radius)
	    {
	    	returnradius*sin(theta);
	    }
	    
	    intmain()
	    {
	        float a = 0.0, r = 0.0;
	        printf("\n\n\ Please, enter the angle theta in degrees:");
	        scanf("%f",&a);
	        printf("\n\n\ Please, enter the radius:");
	        scanf("%f",&r);
	    
	        float t;
	    	t = deg_rad (a);
	    
	    	float x_1, y_1;
	    	x_1 = x_comp (t, r);
	    	y_1 = y_comp (t, r);
	    
	    	printf("\n\n\ theta in radians is = %f", t);
	    	printf("\n\n\ Polar coordinates (%f , %f) ; Rectangular coordinates (%f , %f)",a ,r ,x_1 ,y_1);
	    
	    	return (0);
	    }
	    
	```
	
	Saludos.

* **AngelFA04** (1)

	```
	    //Reto 1
	    //Reto que imprime operaciones aritmeticas entre dos n√∫meros
	    #include <stdio.h>
	    
	    int calculateOp(int a, int b, char op){
	        switch (op)
	        {
	        case'+':
	            return a+b;
	            break;
	        case'-':
	            return a-b;
	            break;
	        case'*':
	            return a*b;
	            break;
	        case'/':
	            return a/b;
	            break;
	        case'%':
	            return a%b;
	            break;
	        }
	    }
	    
	    int main()
	    {
	        int a,b;
	        printf("Introduce un n√∫mero: \n");
	        scanf("%i", &a);
	        printf("Introduce otro n√∫mero: \n");
	        scanf("%i", &b);
	        char operators[] = {'+', '-', '*', '/', '%'};
	        
	        for (int i = 0; i < 5; i++)
	        {
	            printf("%i %c %i = %i\n", a,operators[i],b, calculateOp(a,b,operators[i]));
	        }
	        
	        printf("%i", calculateOp(1,4,'+'));
	    
	        return0;
	    }
	    
	```

* **AngelFA04** (1)

	
	Articulo interesante para el uso de placeholders en la funci√≥n printf  
	<https://www.quora.com/What-are-the-placeholders-used-in-C?share=1>

* **JanethM** (1)

	```
	    // **RETO**
	    #include<stdio.h>
	    // Funcion f
	    // que recibira un argumento de tipo entero
	    // y internamente en la funcion se conocera como a
	    intf(int a){
	        return a * 2;
	    }
	    // Funcion main
	    intmain(){
	        printf("5*2\n");
	        printf("El resultado de la operacion es: %d\n", f(5));
	        return0;
	    }
	    
	```

* **JanethM** (1)

	```
	    // directiva de precompilador
	    // se identifican por que empiezan con #
	    #include<stdio.h>
	    
	    intmain(){
	        // funcion incluida en la libreria stdio.h
	        // muestra informacion en pantalla imprimiendo en la consola
	        printf("Hola Mundo! %d\n", 10);
	        return0;
	    }
	    
	```

* **Miguel Angel** (1)

	
	RETO
	``` 
	    #include<stdio.h>
	    intsum(int a, int b){
	      return a+b;
	    }
	    intsubstraction(int a,int b){
	      return a-b;
	    }
	    intmain(){
	      int a,b;
	      printf("Enter your integer numbers:\n");
	      scanf("%d",&a);
	      scanf("%d",&b);
	      printf("Result:\n");
	      printf("The sum is : %d and the substraction is : %d ",sum(a,b),substraction(a,b));
	      return0;
	    }```
	    
	```

* **Jean Carlos Nu√±ez Hernandez** (1)

	
	las directivas de pre-procesador, como: Include, define ifdef y ifndef le dan algunos tips al compilador de como de interpretar el codigo, es un especie de configuracion de compilador

* **Abdel Mejia** (1)

	
	Un ejercicio simple pero entretenido :3
	
	![Screen Shot 2019-12-05 at 11.16.14 AM.png](https://static.platzi.com/media/user_upload/Screen%20Shot%202019-12-05%20at%2011.16.14%20AM-313d00a3-8c7b-418f-87e8-b30631809123.jpg)![Screen Shot 2019-12-05 at 11.17.29 AM.png](https://static.platzi.com/media/user_upload/Screen%20Shot%202019-12-05%20at%2011.17.29%20AM-4336d6f2-809d-496b-b9d2-d9192aa31c54.jpg)

* **David Felipe Boh√≥rquez** (1)
![challenge.png](https://static.platzi.com/media/user_upload/challenge-4eedf570-129e-470d-9dbf-0f266f4ddc76.jpg)

	* **David Felipe Boh√≥rquez** (1)

		
		![](![challenge2.png](https://static.platzi.com/media/user_upload/challenge2-3ca2712e-9c52-4575-9564-5931752be2ca.jpg)

* **Cristian Alejandro Mu√±oz Cardona** (0)

	
	%d = Numero entero  
	%f = Numero flotante  
	%c = Caracter  
	%s = Cadena de texto

* **Jordan Ronaldo Buitrago Sandoval** (0)
tengo una pregunta en cuanto a la funcion return, entiendo que 0 es falso y todo el resto es verdadero

	* **Juan David Castro (Platzi)** (2)

		
		Estas lecturas te pueden ayudar a aclarar tus dudas:
		
		üëâ <https://www.quora.com/Why-do-we-use-a-return-0-at-the-end-of-a-main-function>  
		üëâ <https://www.geeksforgeeks.org/return-statement-in-c-cpp-with-examples/>  
		üëâ <https://www.quora.com/In-C++-when-making-a-function-does-return-0-means-true-or-false>

## 0090. Conceptos esenciales

### Descripci√≥n:


## Qu√© es una variable

Para entender el concepto de variable es conveniente repasar el de algoritmo.

Voy a tomar una definici√≥n simple:

Un algoritmo es una serie de pasos que deben ejecutarse para lograr un determinado fin.

Algo vago, ¬øcierto? Veamos un ejemplo simple: imagina que tienes que realizar las compras del supermercado para la comida que vas a preparar a la noche.

Mejor a√∫n, imagina que tienes que decirle a otra persona que realice las compras por ti.

Hay ciertas cosas que seguro sabes que debes indicarle:

¬øQu√© hay que comprar? ¬øCu√°nta cantidad? ¬øD√≥nde hay que ir a comprar? Y un largo etc√©tera.

Algunas cosas que dar√°s por sentado ser√°n:

  * Mira antes de cruzar la calle

  * Lleva contigo dinero o tarjeta

  * Cierra la puerta detr√°s de ti




Y algunas otras seg√∫n a qui√©n le est√©s dando estas instrucciones.

Todas estas indicaciones constituyen un algoritmo: un plan detallado que enumera los pasos que deben darse para lograr el objetivo. En este caso: contar con todos los elementos necesarios para cocinar.

Pues bien, y‚Ä¶ ¬ød√≥nde quedaron las variables a todo esto? Un moment√≠n, ya estoy llegando üòÉ

Imagina que la lista de ingredientes es larga.

¬øC√≥mo podr√≠a saber la persona que enviaste a comprar cu√°ndo est√° finalizada su tarea?

La respuesta es clara: cuando se haya comprado el √∫ltimo ingrediente.

Para saber cu√°ndo eso ha sucedido es necesario contar con dos datos:

  1. Cu√°les son todos los ingredientes

  2. Qu√© ingredientes ya han sido agregados al carrito




Lo m√°s probable es que la persona en cuesti√≥n lleve consigo una lista (una simple hoja de papel) con todos los elementos que debe comprar y, a medida que incorpora un nuevo √≠tem al carrito har√° una marca en dicho elemento de la lista (O tal vez lo tache, va en gustos).

El punto es que, sin esta herramienta ser√≠a dif√≠cil completar la tarea exitosamente.

Algunas personas tal vez puedan realizar esta tarea usando solo su memoria, a nuestros efectos, da lo mismo qu√© medio de almacenamiento utilicen, en alg√∫n lado est√° guardada esta informaci√≥n.

En el caso de la computadora el √∫nico lugar donde puede almacenarse informaci√≥n es la memoria (despu√©s podemos discutir tipos de memoria, como ser discos, usb, etc‚Ä¶ pero la idea es la misma).

La memoria de la computadora, como charlamos, est√° organizada en base a celdas contiguas.

Cada celda se identifica por un n√∫mero (Su direcci√≥n).

Dentro de cada celda es posible almacenar una combinaci√≥n de 1s y 0s de un determinado tama√±o (Usualmente un byte es decir, 8 d√≠gitos 0 o 1).

Si necesitamos almacenar un dato m√°s grande que 8 d√≠gitos binarios necesitaremos agregar celdas.

El tema es que, para nosotros los humanos es m√°s f√°cil pensar en algo como $nombre que en 0x00123bf34a.

De hecho, para la computadora es claro que 0x00113bf34a y 0x00123bf34a son dos espacios de memoria que no guardan relaci√≥n alguna. Sin embargo, para nosotros es m√°s f√°cil hablar de $nombre y $email.

Me tom√© una peque√±a licencia aqu√≠ para hacer m√°s claro el ejemplo, a esta altura sabes que las variables en C no comienzan con el caracter $‚Ä¶ ¬øcierto?

De modo que una variable es, a fin de cuentas, un alias para una serie de posiciones de memoria contiguas‚Ä¶ es una forma de hacernos m√°s f√°cil la vida a nosotros‚Ä¶ pobres humanos.

## Qu√© son los tipos de datos

Ahora que hemos aclarado la noci√≥n de variable, demos un paso m√°s y hablemos de tipos de datos.

Como dec√≠a en la secci√≥n anterior, las variables son espacios de memoria formados por celdas de tama√±o fijo.

Para poder almacenar alg√∫n dato en una variable es necesario conocer el tama√±o que √©ste ocupar√° en la memoria‚Ä¶ ¬°de otro modo ser√≠a imposible reservar ese espacio!

Y ah√≠ empieza a tener sentido pensar en la naturaleza del dato que almacenaremos.

Empecemos por un ejemplo simple:

El n√∫mero 7 en binario se escribe como 111. Mejor dicho, en un espacio de 8 bits se escribir√≠a 00000111.

El n√∫mero 255 en binario se escribe 11111111‚Ä¶ en 8 bits no me queda espacio para agregar ning√∫n 1 m√°s: 255 es el n√∫mero m√°s grande que puedo almacenar en una celda de un byte.

¬øY qu√© pasa si necesito almacenar un n√∫mero m√°s grande? Por ejemplo 256.

Pues necesitar√© un bit m√°s, pero‚Ä¶ no puedo simplemente agregar un bit, tengo que anexar todo un byte‚Ä¶ es decir: 00000001 00000000.

Al igual que las variables, los tipos de datos son una forma simple de comprender cu√°nta memoria ocupan nuestros datos (y por ende nuestras variables).

Por otro lado, y esto ya tiene mucho que ver con el lenguaje que usemos, los tipos de datos nos dan una idea de qu√© operaciones puede realizarse con los datos que tenemos almacenados.

Por ejemplo, cualquiera esperar√≠a que la suma de dos n√∫meros enteros no supusiera ning√∫n problema‚Ä¶ sin embargo, la divisi√≥n de una palabra por otra no parece tener mucho sentido, ¬øcierto?

Cada lenguaje define un conjunto de tipos y operaciones permitidas sobre ellos.

A estos tipos se los conoce como primitivos.

Claro que no son los √∫nicos posibles: t√∫ puedes definir tus propios tipos de datos.

## Qu√© es un struct

Un struct es un mecanismo para definir nuevos tipos de datos complejos o estructurados.

Se usa cuando tienes que guardar datos correlacionados, por ejemplo, todos los referidos a una persona.

Cuando tienes que manejar muchas personas y de todas ellas quieres recabar la misma informaci√≥n tiene mucho sentido armar una estructura a partir de la cual puedas crear nuevas variables.

En el caso de C, los structs son un modo muy interesante de crear tus propios tipos de datos, ya sea combinando los tipos primitivos o, incluso, utilizando otros structs.

## Qu√© es una funci√≥n

Una de las necesidades m√°s comunes que nos encontramos a la hora de desarrollar (especialmente aplicaciones de cierta complejidad) es la de re-utilizar partes del c√≥digo que hemos escrito.

Siempre es posible copiar y pegar, pero si tienes algo de experiencia r√°pidamente te dar√°s cuenta de que no es precisamente una buena pr√°ctica (Y de paso, si quieres aprender algunas de las que s√≠ lo son, [este curso](https://platzi.com/clases/mejor-codigo/) puede interesarte).

Una funci√≥n es un pedazo de c√≥digo que tiene asociado un nombre y retorna un valor al finalizar su tarea.

De esta forma, puede ser invocada cada vez que se la necesite y, una vez haya concluido, el valor de retorno ser√° el que tome la expresi√≥n de la llamada.

Es decir, en un fragmento de este estilo:

a = f(5);

La variable a tomar√° el valor resultante de invocar a la funci√≥n f con un argumento igual a 5.

## Qu√© significa la palabra reservada ‚Äúconst‚Äù

Respecto de algo que habr√°s visto en los ejemplos del curso, habr√°s notado que utilic√© la palabra reservada const, especialmente para los strings.

Esta palabra es un modificador de un tipo de datos.

Lo que indica const es que el contenido de la variable no podr√° ser sobreescrito.

Este tipo de aclaraci√≥n tiene especial relevancia cuando se trabaja con punteros.

La diferencia entre char * c y const char * c es que en el primer caso nada me impide hacer algo como *c = ‚ÄòB‚Äô, mientras que en el segundo obtendr√© un error.

Se trata en definitiva de un mecanismo de seguridad m√°s (seguridad en el sentido de asegurarnos que nuestro programa no escribe donde no debe).

### Comentarios:

* **Juan Antonio Oriza** (5)

	
	Interesante explicaci√≥n de la palabra reservada ‚Äúconst‚Äù, solo como complemento a lo explicado. Este tipo de ‚Äúseguridad‚Äù se le conoce tambien como ‚Äúprincipio de menor privilegio‚Äù, en donde no se le permite a m√≥dulos de software, tales como funciones, modificar aspectos mas alla para lo que fueron creados.

* **Miguel Bedoya** (1)

	
	Un ejemplo de como usar struct para definir un nuevo tipo de datos estructurados:
	
	struct Person  
	{  
	char name[50];  
	int id;  
	float salary;  
	};

* **Julian Guarin** (1)

	
	Const:
	
	  1. Es un atributo de una variable.
	  2. Le indica al compilador que se debe abstener de generar instrucciones para escribir en dicha variable.
	  3. Dado 2, cualquier intento del c√≥digo por escribir en dicha variable generar√° un error de compilaci√≥n.
	
	

# Entender conceptos m√°s profundos del lenguaje C

## 0100. Punteros

### Descripci√≥n:


### Comentarios:

* **Jose Oliva Rivera** (4)

	
	Este tema es clave para entender C, se debe prestar mucha atenci√≥n.

* **gydoar** (4)

	
	Nunca entend√≠ esta clase en la Universidad, espero me sorprenda profesor,

	* **Juan David Castro (Platzi)** (2)

		
		Tambi√©n te pueden ayudar estas clases del curso de C++: <https://platzi.com/clases/1545-c-plus-plus/19070-que-son-los-apuntadores/>. üòâ

	* **Mauro Chojrin** (2)

		
		@gydoar Ojal√° que s√≠! Cualquier duda puedes dejar tu pregunta!

* **Jean Carlos Nu√±ez Hernandez** (2)

	
	No hay algo mas dificil de manejar que punteros en C, segun asi lo ruerdo en la universidad, pero esta explicacion es muy facil de asimilar

* **onyx** (2)

	
	el curso esta muy flojo, tenie en varios videos errores de codigo que no llega a suceder por mera casualidad como setea las variables, ademas de que aplica muchas malas practicas, se que es introductorio, pero veo que es mas para alguien que ya sabe low-level con otro lenguaje y quiere rapidamente ver como se hace en C

* **predator0077** (2)

	
	Me exploto la cabeza pero logre, aprender un poco mas de los punteros

* **David Felipe Boh√≥rquez** (2)

	
	Excelente clase, muy claro.

	* **Mauro Chojrin** (1)

		
		Gracias!! Me alegra que te haya gustado üòÉ

* **Cristian Rosales** (1)

	
	¬°Excelente explicaci√≥n!

* **EPadronU23** (1)

	
	Simplemente brillante la forma en que fueron explicados los punteros. Mis respetos.

* **ppastram** (1)

	
	Hola. Al correr mi programa en la terminal de Mac, tengo problemas con los punteros, pues me parecen los errores error: expected expression -> printf(%p, pointToNumber); y error: use of undeclared identifier ‚Äòp‚Äô -> printf(%p, pointToNumber);  
	¬øAlguien sabe que debo hacer?  
	¬°Gracias!

	* **JanethM** (1)

		
		Es por que te falto poner entre comillas el %p  
		asi no deberia marcarte ningun error:  
		printf( **"** %p **"** , pointToNumber);

* **pablohugomontenegro** (1)
por que pone int main() en lugar de main solo?

	* **Arturo O. T√©llez** (1)

		
		Porque se especifica el tipo de dato que retorna la funci√≥n main. Si no optamos por no poner int main(); se puede cambiar por void main(). Pero al final no se debe de incluir el return. üòÉ

* **braulioondoedu** (1)
la verdad es que no quiero ser critico, pero el curso pone introduccion y se ssupone que en una introduccion se ttiene que ensenhar desde...

	* **Juan David Castro (Platzi)** (1)

		
		Este curso est√° 100% enfocado en conocer las caracter√≠sticas de C y todas las posibilidades que nos ofrece. Pero tambi√©n puedes estudiar con el curso de programaci√≥n estructurada, vamos un poco m√°s despacio y aprendiendo sobre l√≥gica de programaci√≥n: <https://platzi.com/clases/programacion-estructurada/>.

* **Nahuel Ramos** (0)

	
	No tiene mucho que ver con la clase, pero no puedo usar ctrl + shift + u + unicode para escribir caracteres especiales en la terminal o en vim. Lo raro es que si me funciona en el navegador. Estoy usando kali en Virtual Box. Si alguien podr√≠a darme una mano ser√≠a genial. Muchas gracias.

## 0110. Usos pr√°cticos de los punteros

### Descripci√≥n:


### Links:

* [platzi-curso-c/scanf.c at master ¬∑ mchojrin/platzi-curso-c ¬∑ GitHub](https://github.com/mchojrin/platzi-curso-c/blob/master/scanf.c)

* [platzi-curso-c/by_ref.c at master ¬∑ mchojrin/platzi-curso-c ¬∑ GitHub](https://github.com/mchojrin/platzi-curso-c/blob/master/by_ref.c)

### Comentarios:

* **Juan Antonio Oriza** (9)

	
	 **Las funciones pueden pasar valores de dos formas en C:**
	
	  * **Por valor:** Esta es la forma predeterminada en como C pasa los valores a sus funciones. Se crea una copia de la variable que se le pasa como argumento, quedando la variable original inalterada.
	
	  * **Por referencia:** Esta es la forma en como C puede modificar las variables que son pasadas como argumentos de la funci√≥n. Hace uso de apuntadores, pasando, como su nombre lo indica, una referencia a la posici√≥n de memoria de la variable que se maneja como argumento, permitiendo alterar su valor.
	
	
	

	* **Abdel Mejia** (2)

		
		Esto se conoce como:
		
		  * Reference
		  * Derefence
		
		

* **elvis.sanchez** (3)

	
	Cool. Como en Golang ‚ù§Ô∏è

* **Jean Carlos Nu√±ez Hernandez** (1)

	
	en el caso de C el pasaje por referencia se realiza por los punteros

* **David Felipe Boh√≥rquez** (1)
¬øAlg√∫n curso de platzi recomendado para aprender los comandos m√°s importantes de VIM?

	* **Erik Ochoa (Platzi)** (4)

		
		No se tiene un contenido especifico sobre ese tema, pero ac√° encontr√© un link que te puede servir. [Vim Basics](https://coderwall.com/p/adv71w/basic-vim-commands-for-getting-started).

* **Edgar Mu√±oz** (0)
hola amigos, donde puedo encontrar ejercicios para practicar programaci√≥n en C gracias.

	* **Juan Felipe Peralta Zapata (Platzi)** (3)

		
		¬°Hola, Edgar! ‚ö°
		
		B√°sicamente cualquier ejercicio de programaci√≥n puedes adaptarlo al lenguaje que desees.
		
		Aqu√≠ te dejo algunos enlaces que te pueden servir para encontrar p√°ginas con ejercicios de programaci√≥n:
		
		  * [HackerRank: Plataforma online para practicar c√≥digo](https://platzi.com/tutoriales/1050-programacion-basica/1918-hackerrank-plataforma-online-para-practicar-codigo/).
		  * [Cinco sitios online con retos de programaci√≥n donde poder mejorar nuestro c√≥digo](https://www.genbeta.com/desarrollo/cinco-sitios-online-con-retos-de-programacion-donde-poder-mejorar-nuestro-codigo).
		
		

## 0120. Aritm√©tica de punteros

### Descripci√≥n:


### Links:

* [platzi-curso-c/wrong_pointer.c at master ¬∑ mchojrin/platzi-curso-c ¬∑ GitHub](https://github.com/mchojrin/platzi-curso-c/blob/master/wrong_pointer.c)

* [platzi-curso-c/inc_pointer.c at master ¬∑ mchojrin/platzi-curso-c ¬∑ GitHub](https://github.com/mchojrin/platzi-curso-c/blob/master/inc_pointer.c)

### Comentarios:

* **Cristian Rosales** (2)

	
	Como copiar y pegar en [Vim ](https://riptutorial.com/es/vim/example/18668/copiar--cortar-y-pegar) .

* **guillermogranado** (2)

	
	He realizado el ejemplo de wrong_pointer y mi puntero no apunta a la memoria de la variable b al incrementarlo.  
	Sabes por que puede ser?  
	Estoy usando clang sobre MacOS  
	Te comparto el ejemplo que he realizado y el resultado
	``` 
	    #include <stdio.h>
	    
	    int main() {
	        int * pi;
	        int a = 5;
	        int b = 1;
	    
	        pi = &a;
	    	printf( "Antes\n\t a = %d, &a = %p, b = %d, &b = %p, p = %p\n", a, &a, b, &b, pi );
	    	pi++;
	    	*pi = 10;
	    	printf( "Despues\n\t a = %d, &a = %p, b = %d, &b = %p, p = %p\n", a, &a, b, &b, pi );
	    
	        return0;
	    }
	    
	```
	
	Y el resultado es el siguiente:
	``` 
	    Antes
	             a = 5, &a = 0x7ffee93a376c, b = 1, &b = 0x7ffee93a3768, p = 0x7ffee93a376c
	    Despues
	             a = 5, &a = 0x7ffee93a376c, b = 1, &b = 0x7ffee93a3768, p = 0x7ffe0000000a
	    
	```

	* **David Felipe Boh√≥rquez** (2)

		
		Tal vez tiene algo que ver con la manera en la que se maneja la memoria en Ubuntu. Yo uso Fedora y me di√≥ igual que a t√≠, sin embargo en una maquina virtual con Ubuntu prob√© el mismo c√≥digo y si se pis√≥ la direcci√≥n de memoria de la variable b.

	* **David Felipe Boh√≥rquez** (2)

		
		![](![wrongpointer.png](https://static.platzi.com/media/user_upload/wrongpointer-2dd45202-613c-406f-9ad0-3cb5af5d40ac.jpg)

	* **Mauro Chojrin** (5)

		
		Es posible que eso suceda debido al compilador que usas, a la arquitectura de la computadora o al sistema operativo.
		
		Lo importante igual es comprender que se est√° accediendo a una direcci√≥n de memoria desconocida y, por lo tanto, se puede estar sobre-escribiendo informaci√≥n que no estamos controlando.

	* **Jeffersson Mu√±oz Torres** (1)

		
		Al parecer la direcci√≥n de memoria de la variable ‚Äòb‚Äô es menor a la de la variable ‚Äòa‚Äô.  
		_Recordemos que las direcciones de memoria no est√°n en el sistema decimal, sino, en el sistema hexadecimal._  
		.  
		Es por eso, que al sumar a la direcci√≥n de memoria de la variable ‚Äòa‚Äô esta sigue siendo mayor, cuando lo que deber√≠a ocurrir es que sean igual las direcciones de ‚Äòa‚Äô y ‚Äòb‚Äô.

* **Josue12** (1)

	
	Que pasar√≠a si le asignas un valor a un puntero que no apunta a ninguna variable?

	* **Samuel Mauricio Braganza Zorilla** (1)

		
		Pues solo cambiaria el valor del puntero, y no cambiaria el valor de otra variable.  
		Por ejemplo:
		
		int numero = 520;  
		int * puntero;  
		*puntero = 560;
		
		Los valores de las variables serian:  
		numero --> 520  
		puntero --> 560

* **Jair Sebastian Lozano Moron** (1)

	
	Consulta, porque enteros ocupan el tama√±o de 4 bytes y un car√°cter solo 1?

	* **JanethM** (3)

		
		 **Los tipos de dato entero disponibles y su tama√±o dependen del lenguaje de programaci√≥n usado as√≠ como la arquitectura en cuesti√≥n.**
		
		**Los caracteres** se representan utilizando el tipo char, que tiene s√≥lo 1 byte de tama√±o. Este tipo se utiliza para representar los 256 caracteres de la tabla de caracteres del sistema. El tipo char es tambi√©n un tipo entero, ya que puede tomar valores de 0 a 255. Por lo tanto tambi√©n puede ser signed o unsigned.
		
		Un **tipo de dato entero** en computaci√≥n es un tipo de dato que puede representar un subconjunto finito de los n√∫meros enteros. El n√∫mero mayor que puede representar **depende del espacio usado por el dato y la posibilidad (o no) de representar n√∫meros negativos.**
		
		Por ejemplo, si para almacenar un n√∫mero entero disponemos de 4 bytes de memoria tememos que:
		
		4 bytes = 4 √ó 8 = 32 bits  
		Con 32 bits se pueden representar 232 = 4294967296 valores:  
		Solo positivos (enteros sin signo): del 0 al 4294967295  
		Positivos y negativos (enteros con signo): del -2147483648 al 2147483647

* **Jean Carlos Nu√±ez Hernandez** (1)

	
	Muy facil la aritmetica con punteros

## 0130. Arreglos

### Descripci√≥n:


### Links:

* [platzi-curso-c/array_out_of_bounds.c at master ¬∑ mchojrin/platzi-curso-c ¬∑ GitHub](https://github.com/mchojrin/platzi-curso-c/blob/master/array_out_of_bounds.c)

* [platzi-curso-c/array_definition.c at master ¬∑ mchojrin/platzi-curso-c ¬∑ GitHub](https://github.com/mchojrin/platzi-curso-c/blob/master/array_definition.c)

### Comentarios:

* **Jeffersson Mu√±oz Torres** (3)

	
	Nuevo conocimiento adquirido:  
	El compilador y/o la maquina virtual que ejecuta alg√∫n programa que contenga arreglos para poder recorrerlo todo hace uso de **punteros** . ü§Ø

* **Alejandro Urrea Giraldo** (2)

	
	Para ilustrar los conceptos aprendidos en esta clase, comparto un programa en C donde se ve claramente como se asignan direcciones de memoria contiguas al definir un arreglo, y como el tipo de dato afecta el tama√±o de memoria reservado para cada dato
	
	![c_array_memory_definition.png](https://static.platzi.com/media/user_upload/c_array_memory_definition-615f603d-df6a-4193-9384-873cba39be0b.jpg) ![r_array_memory_definition.png](https://static.platzi.com/media/user_upload/r_array_memory_definition-d108f5d6-85e4-4615-9a9b-3e21ad357df5.jpg)
	
	En el arreglo de los enteros, las posiciones reservadas son contiguas, y cada dato ocupa 4 bytes
	
	En el arreglo de los caracteres, las posiciones reservadas tambi√©n son contiguas, pero cada dato ocupa menos memoria (1 byte por cada dato)
	
	Las direcciones de memoria **reservadas** y **contiguas** , permiten que los vectores puedan ser recorridos incrementando el puntero que est√° referenciado a la posici√≥n 0 del arreglo

* **Steven Moreno** (2)

	
	 **En definitiva debo instalar Ubuntu en windows‚Ä¶**
	
	#include <stdio.h>
	
	int main()  
	{  
	int array[5];  
	int i;
	
	for (i = 0; i < 5; i++)  
	{  
	array[i] = i * 2;  
	}
	
	for (i = 0; i < 6; i++)  
	{  
	printf(‚Äúarray[%d] = %d\n‚Äù, i, array[i]);  
	}
	
	array[6] = 81;  
	}
	
	**Resultado**
	
	array[0] = 0  
	array[1] = 2  
	array[2] = 4  
	array[3] = 6  
	array[4] = 8  
	array[5] = 5

	* **Juan David Castro (Platzi)** (3)

		
		En el Curso de Introducci√≥n a la Terminal puedes aprender c√≥mo: <https://platzi.com/clases/terminal/>.
		
		Tambi√©n en el curso de Prework: <https://platzi.com/clases/prework/>.

	* **onyx** (2)

		
		usa vagrant, muy bueno, portable y ligero

* **JanethM** (1)

	```
	    #include <stdio.h>
	    
	    int main(){
	        int array[5];
	        int i;
	    
	        for (i = 0; i < 5; i++)
	        {
	            array[i] = i * 2;
	        }
	    
	        for (i = 0; i < 5; i++)
	        {
	            printf("array[%d] = %d\n", i, array[i]);
	        }
	    
	        return0;
	        
	    }
	    
	```

* **Jean Carlos Nu√±ez Hernandez** (1)

	
	los arreglos son variables que almacenan varios valores a la vez

## 0140. Strings

### Descripci√≥n:


### Comentarios:

* **onyx** (8)

	
	tener en cuenta que el largo de la palabra no se calcula, lo que hace el compilador es agregar un ‚Äúflag‚Äù de terminacion nulo en la palabra, asi por ejemplo printf(), sabe hasta donde imprimir la palabra ‚ÄúMauro‚Äù, me explico:
	
	Aqui definimos una variable de tipo ‚Äúchar *‚Äù la la cual le damos la direccion a la palabra mauro, la cual esta almacenada en el ‚Äústack‚Äù, (Sector de memoria de lectura durante el runtime)
	``` 
	    char *str  = "Mauro";
	    
	```
	
	la cosa es que en realidad lo que hizimos fue hacer esto:
	``` 
	    char *str  = "Mauro\0";
	    
	```
	
	el carater ‚Äò\0‚Äô es un caracter especial que indica una terminacion nula, en pocas palabras es el caracter de la posicion cero en la tabla ASCII
	
	por lo cual pordemos iterar sobre toda la palabra sin saber implicitamente su largo
	``` 
	    // libreria para la funcion "write"
	    #include<unistd.h>
	    
	    voidput_char(char c)
	    {
	        // write es una funcion de llamada al sistema para imprimir
	        // al standart output, por ahora pueden pensarlo como
	        // que simplemente esta imprimiendo un caracter
	    	write(1, &c, 1);
	    }
	    
	    intmain(void)
	    {
	        // definimor la variable
	    	char *str = "Mauro";
	    
	        // en cada iteracion movemos el puntero hasta que el valor
	        // que almacena el mismo sera '\0'
	    	for (; *str; str++)
	    	{
	    		put_char(*str);
	    	}
	    	
	    	// imprimimos la nueva linea
	    	// recuerden que "\n" != '\n'
	    	put_char('\n');
	    }
	    
	```
	
	si tienen algun duda no duden en preguntar, y agradecere su laik prros :v

* **guillermogranado** (2)
Podr√≠ais compartirme enlaces con documentaci√≥n sobre el lenguaje C? No me importa si esta en ingl√©s (casi que lo prefiero). Gracias

	* **Danelia Sanchez Sanchez** (2)

		
		<https://en.cppreference.com/w/c>

* **Samuel Mauricio Braganza Zorilla** (1)

	
	Tengo dos variables: char * cadena e int * numero. Porque al inicializar de esta forma:
	``` 
	    char * cadena = "Samuel";
	    int * numero = 654;
	    
	    printf("Cadena: %s", cadena);
	    printf("Numero: %d", numero);
	    
	```
	
	Me ocasiona problemas en el numero y no en la cadena ?.  
	Se imprime la cadena sin problema pero el numero no, me menciona este error al compilar:
	``` 
	    primer_string.c: Infunction ‚Äòmain‚Äô:
	    primer_string.c:6:17: warning: initialization makes pointer from integer without a cast [-Wint-conversion]
	      int * numero = 55;
	                     ^~```
	    
	    
	```

* **Luis_Cruz_Cruz** (1)

	
	Hola a todos,
	
	Les comparto el resultado de esta lecci√≥n;
	
	![Lesson_14.jpg](https://static.platzi.com/media/user_upload/Lesson_14-8c3e61f6-c55e-4e83-a839-c8c5b07ed720.jpg)

* **JanethM** (1)

	```
	    #include<stdio.h>
	    
	    intmain()
	    {
	        char * name = "Esther";
	    
	        printf("Nombre = %s, (%p)\n", name, name );
	    
	        for (int i = 0; i < 6; i++)
	        {
	            printf("name[%d](%p) = %c\n", i, name + i, *(name+i));
	        }
	        
	    }
	    
	```

* **onyx** (1)
tener en cuenta que el largo de la palabra no se calcula, lo que hace el compilador es agregar un ‚Äúflag‚Äù de terminacion nulo en la palabr...

## 0150. Strings y memoria

### Descripci√≥n:


### Comentarios:

* **LuqueDaniel** (3)

	
	El operador ternario permite realizar un peque√±o condicional en una sola linea.
	``` 
	    char* resultado = (puntuacion >= 6) ? "Aprobado" : "Suspenso";
	    
	```

* **Jordan Ronaldo Buitrago Sandoval** (2)

	```
	    #include <studio.h>
	    
	    /*_strlen function*/
	    int _strlen(char *s)
	    
	    {
	    	int a = 0;
	    
	    	while (s[a])
	    		++a;
	    
	    	return (a);
	    }
	    
	    
	    /*_strcmp function*/
	    int _strcmp(char *s1, char *s2)
	    {
	    	int count = 0;
	    
	    	while (s1[count] != '\0')
	    	{
	    		if (s1[count] > s2[count])
	    			return (1);
	    		elseif (s1[count] < s2[count])
	    			return (-1);
	    		count++;
	    	}
	    	return (0);
	    }
	    
	    int main()
	    {
	    	char *name = "Youknow";
	    	char *othename = "luxy";
	    
	    	printf("Los nombres son %s\n", _strcmp(name, othenamer) == 0 ? "iguales" : "distintos");
	    
	    	return (0);
	    }
	    
	```

* **Jean Carlos Nu√±ez Hernandez** (1)

	
	\0 es importante al final de cada string

* **Jos√© Eduardo Reyes Yol** (1)
¬øCu√°l es la verdadera diferencia entre char * str ="Mauro"; , char str = "mauro" y char str[] = "mauro...

	* **Juli√°n David Cubillos Orteg√≥n** (1)

		
		char * str = ‚ÄúMauro‚Äù se define un arreglo de string y es otra manera de decir char str[] = "Mauro"  
		Diferente a char str = ‚ÄúMauro‚Äù el que aunque define una variable char y escribe una palabra solamente es una variable y no un arreglo o vector la lectura en memoria sera diferente‚Ä¶

## 0160. Par√°metros de l√≠nea de comandos

### Descripci√≥n:


### Comentarios:

* **David Felipe Boh√≥rquez** (5)

	
	Como entusiasta novato de Unix y Linux creo que este curso est√° estupendo para entender mejor como funcionan.

* **jimezam** (4)
Para evitar problemas de buffer overflow como se menciona al final del video, lo mejor es utilizar la variante N de las funciones de string.h. En lugar de usar strcpy se deber√° utilizar strncpy la cual permite especificar la longitud m√°xima a copiar.

* **Jean Carlos Nu√±ez Hernandez** (2)

	
	main parametros int argc y char * argv[], son sus parametros por defecto

* **Juan Fernando Romero Ortega** (1)

	
	Esto es lo que arroja la consola, a la pregunta de abajo.
	``` 
	    PS D:\Curso Introduccion C> .\buffer_overflow 1212312123123123123123123123123123123123123
	    Original buffer: This will be overwritten```
	    
	```

* **Juan Fernando Romero Ortega** (1)

	
	Saludos, otra duda, porque no me arroja error? lo unico que veo que pasa en mi consola es que la segunda linea de printf no se ejecuta, pero no arroja el error como tal, estoy en visual studio code
	``` 
	    #include<stdio.h>
	    #include<string.h>
	    
	    intmain(int argc, constchar * argv[]){
	        char buffer[20];
	        char * buffer2 = "This will be overwritten";
	        printf("Original buffer: %s\n", buffer2);
	        strcpy(buffer, argv[1]);
	        printf("New buffer2: %s\n", buffer2);
	    
	        return0;
	    }```
	    
	    
	```

	* **JanethM** (1)

		
		Depende de como tu sistema operativo vaya a manejar el problema, yo por ejemplo estoy en windows y lo que hace es que me lanza una ventana de que se a detectado un problema y si quiero cerrarlo

* **Juan Fernando Romero Ortega** (1)

	
	Saludos, una duda, porque imprimimos ‚Äúprintf(New buffer2: %s\n‚Äù, buffer2);" si la variable a la que se le copia es a buffer. ?

	* **JanethM** (1)

		
		Hola  
		es un ejemplo, lo que va a causar la falla es cuando queremos sobreescribir en la variable buffer un dato de mayor espacio que el espacio que definimos desde un principio para buffer, en el ejemplo simplemente vamos imprimiendo en consola para que veas que el programa se esta ejecutando y al ver que no te imprime la segunda linea puedes notar que algo anda mal

## 0170. Definici√≥n de tipos de datos estructurados

### Descripci√≥n:


### Comentarios:

* **ffranco_** (4)

	
	Est√° genial el curso, en poco tiempo alcanc√© el punto que llegu√© en la universidad. Incluso aprend√≠ nuevas cosas como la comparaci√≥n en l√≠nea y el modificador cont en los comandos üòÑ Este curso ha sido muy bien elaborado

* **Jos√© Eduardo Reyes Yol** (2)

	
	Para mis compa√±eros que, c√≥mo yo, a√∫n no entienden bien los punteros, aqu√≠ les dejo un documento en PDF que encontr√© en internet d√≥nde explican muy bien los punteros y c√≥mo funcionan en el lenguaje C. <https://lsi.vc.ehu.eus/pablogn/docencia/manuales/C/Punteros_en_C.pdf>

* **Jos√© Eduardo Reyes Yol** (2)

	
	EL curso hasta este punto est√° genial. Sin embargo me gustar√≠a que fuera un poco m√°s pr√°ctico. Ya que los ejemplos que realizamos en clase son muy simples y no nos ense√±an c√≥mo resolver problemas m√°s complejos utilizando varias herramientas juntas.

* **Lorenzo David Lezcano** (2)

	
	El curso es interesante, pero creo que va un poco rapido

	* **Miguel Ramos** (2)

		
		Me parece que el problema no es la velocidad si no el entendimiento de algunos conceptos que lo hacen perder a uno, creer√≠a que la percepci√≥n depende de la capacidad de entendimiento, ya que este es un lenguaje de bajo nivel por lo que su comprensi√≥n puede ser mas complicada que un PHP o un JavaScript.
		
		Ten paciencia mi amigo y trata de apoyarte en documentaci√≥n al principio tambi√©n me dio duro entender esto.

	* **Oscar Grey** (2)

		
		Como dice Miguel , es por comprensi√≥n , para entender las bases de un lenguaje o desarrollar una buena abstracci√≥n hace falta tiempo , entrenamiento y sobre todo equivocarse.  
		Sobre todo equivocarse , esto te permitir√° a deconstruir malos entendimientos , en pocas palabras sabr√°s por tu propia experiencia que hace y que no hace cada utilidad.  
		En mi caso me ha parecido f√°cil ya que vengo de otros lenguajes como Python o Javascript . Que sus bases son muy parecidas , s√≥lo que no son tan fuertemente tipados. Y puedo afirmar que hasta ahora hay una igualdad muy marcada en ellos. Desde la forma de trabajar con funciones/variables hasta el manejo de strings por caracteres , en el que se parece mucho con Python por cierto .

* **Sebastian Augusto Baez Ramos** (2)

	
	Conociendo la programaci√≥n orientada a objetos, ¬øes mejor hacer manejo de estos tipo de datos con ese paradigma o que diferencia tendr√≠a con el manejo de ‚Äústruct‚Äù?

	* **Matias Sebastian Perez** (7)

		
		En este caso, C no soporta el **paradigma orientado a objetos**. En mi opinion los **structs** sirven mas para encapsular variables con el mismo proposito, o que describan algo en comun, y creo que para el caso de la ficha con datos del empleado, es mucho mas conveniente un paradigma orientado a objetos por las ventajas que este nos brinda, tales como: **Herencia** , **Encapsulamiento** y **Polimorfismo**.

	* **onyx** (5)

		
		los struct van a servir mucho para casos como cuando quieres pasar varios argmentos relacionados a una funcion sin declararlos todos, sirven para las linked lists, double linked lists, para punteros a funciones, y mas cosas avnzandas que se pueden hacer para manejar datos en C

* **Jean Carlos Nu√±ez Hernandez** (1)

	
	Struct donde podemo crear un nuevo tipo de dato estructurado

* **Erick Lopez** (1)
porque en el primer if definimos que (argc < 3) ??

	* **Jorge Luis Lopez Santiz** (1)

		
		por que en argc es donde se hace el conteo de los datos que se envian desde el sistema operativo (cuando se escribe algo desde la terminal)

* **ffranco_** (1)
Una duda fuerte. Por qu√© en el minuto 2:40 en lugar de asignar el nombre mediante person.name = argv[1]; Utiliza la funci√≥n...

	* **Diego Alexander Forero Higuera (Platzi)** (2)

		
		Es una funci√≥n cuya funci√≥n es hacer una copia del string que del source al destino, los argumentos son la variable de destino y el source. Adicionalmente provee una serie de validaciones como que no se pueda almacenar una string m√°s largo que la variable de destino.

* **Miguel Ramos** (1)
Podr√≠a decir que puedo usar struct como una especie de modelo?

	* **AnthonySQC** (1)

		
		Si Miguel, con struct podemos definir un modelo que se compone con datos definidos en C o con otras structs, por ejemplo podemos definir una coordenada de un tablero de la siguiente forma:
		``` 
		    struct{
		    	int fila;
		    	int columna;
		    }coordenada;
		    
		```
		
		Y podemos definir una struct que modele las coordenadas realizadas por los jugadores(si pensamos en alg√∫n juego en el que los jugadores marcan casillas):
		``` 
		    struct{
		    	int jugador;
		    	coordenada seleccion;
		    }jugada;
		    
		```
		
		Espero que esto te ayude, un saludo.

## 0180. Alias de tipos de datos

### Descripci√≥n:


### Comentarios:

* **Abdel Mejia** (5)

	
	Esto es genial! ü§ñ

* **Nicolas David Pastran Zamora** (1)

	
	En algunas veces se necesitan algunos tipos de datos que est√©n m√°s cerca a nuestra aplicaci√≥n, con el fin que la aplicaci√≥n sea entendible conceptualmente para su f√°cil mantenimiento, para esto se usan unos sobre nombres definidos con typedef (tipo de dato primitivo).

* **Luis Fernando Zarazua Aguilar** (1)

	```
	    #include<stdio.h> //Directiva de precompilador (inclusi√≥n de archivo).
	    #include<string.h>
	    #include<stdlib.h>
	    
	    typedefchar NOMBRE[100];//Se define un nuevo tipo de dato
	    typedefint EDAD;
	    
	    struct persona{           
	            NOMBRE nombre;
	            EDAD edad;
	    };
	    
	    voidRellenarDatosPersona(struct persona * personaje, constchar * nombre, int edad)
	    {
	        if (strlen(nombre) < 100)
	        {
	            strcpy((*personaje).nombre, nombre);
	        }
	       personaje->edad= edad;//(*personaje) se puede sustituir por ->.
	    }
	    
	    intmain(int argc, char * argv[])
	    {
	        struct persona personaje;
	        
	        if (argc < 3)
	        {
	            printf("Indique nombre y edad por favor\n");
	            return1;
	        }
	        
	        RellenarDatosPersona(&personaje, argv[1], atoi(argv[2]));
	        printf("Nombre = %s edad = %d\n", personaje.nombre, personaje.edad);
	    
	        return0;
	        
	    }```
	    
	```

* **ffranco_** (1)

	
	Buen√≠sima clase

## 0190. Crear bibliotecas propias

### Descripci√≥n:


### Comentarios:

* **gnbarzol** (2)

	
	Reto cumplido!
	``` 
	    #include<stdio.h>
	    #include<stdlib.h>
	    #include<string.h>
	    
	    
	    int main( int argc , constchar * argv[]){
	    
	        if( argc <= 2 ){
	            printf("Ingrese al menos dos cadena de texto\n");
	            return1;
	        }
	    
	        intsize=0, position;
	    
	        for(int i=1; i<argc; i++){
	            if( strlen(argv[i]) > size ){
	                size = strlen(argv[i]);
	                position = i;
	            }
	        }
	    
	        printf("La cadena m√°s larga es: %s, con %d caracteres", argv[position], size);
	        return0;
	    }
	    
	```

	* **Johan Lisandro Castiblanco** (1)

		
		Buena esta solucion al estlo sort, me gusto porque no importa el numero de cadenas q se pongan‚Ä¶sacara la mas larga de todas.

* **Abdel Mejia** (2)

	
	En c tambi√©n existe librer√≠as est√°ticas y librer√≠as din√°micas(compartidas).
	
	Las cuales te permiten incorporar mediante la directiva `#include` los s√≠mbolos necesarios en nuestro ejecutable al momento de linkear en nuestro ejecutable, con la ayuda de las referencias que tenemos en nuestro Header File o archivo de cabecera.
	
	Las est√°ticas te incrustan los s√≠mbolos en el ejecutable.
	
	Las din√°micas estas en alguna parte de tu memoria y le pasan a tu ejecutable los s√≠mbolos solo en el momento que la usara al ejecutar tu programa, eso lo hace diciendo a cada programa donde esta ubicado por medio de una direcci√≥n relativa. De esta forma solo tengo una librer√≠a para multiples ejecutables, aunque esto tambi√©n lo vuelve mas lento.
	
	Nota: las librerias estandar son dinanimas (stdio, stdlib‚Ä¶)
	
	[Ver m√°s](http://docencia.ac.upc.edu/FIB/USO/Bibliografia/unix-c-libraries.html#what_is_a_library)

* **Matias Sebastian Perez** (2)

	```
	    #include<stdio.h>
	    #include<string.h>
	    
	    intmain(int argc, constchar * argv[]){
	        char longest_str[50];
	        strcpy(longest_str, argv[1]);
	    
	        for(int i = 2; i < argc; i++){
	            if(strlen(longest_str) < strlen(argv[i]) ){
	                strcpy(longest_str, argv[i]);
	            }
	        }
	    
	        printf("The biggest string is: %s", longest_str);
	        return0;
	    }
	    
	```

* **Vicnow** (2)

	
	Este es mi codigo ‚ù§Ô∏è, ¬°Animo!!!
	``` 
	    #include<stdio.h>
	    #include<string.h>
	    
	    intmain(int argc, char* argv[]){
	    
	        if (argc==1)
	        {
	            printf("Incluye almenos una cadena de texto");
	            return1;
	        }
	        
	    
	        int comp = 0;
	        char cadenaMasLarga[100];
	    
	        for (int i = 1; i < argc; i++)
	        {
	            printf("Cadena %d = %s\n",i,argv[i]);
	    
	            if (strlen(argv[i])>comp){
	                comp = strlen(argv[i]);
	                strcpy(cadenaMasLarga,argv[i]);
	            }
	        }
	    
	        printf("Cadena mas larga = %s\n",cadenaMasLarga);
	        
	    }
	    
	```

* **cr-daniel-brayan** (2)

	
	¬°Hola a todos! les comparto mi soluci√≥n al challenge.
	``` 
	    #include<stdio.h>
	    #include<string.h>
	    
	    intmain(int argc, char * argv[])
	    {
	        char * largestString = "";
	        for(int i=1; i<argc; i++)
	        {
	            printf("Argument %d = %s\n", i, argv[i]);
	            if(strlen(argv[i])>strlen(largestString))
	            {
	                largestString=argv[i];
	            }
	        }
	        printf("The largest argument is %s\n",largestString);
	    
	        return0;
	    }
	    
	```

	* **Mauro Chojrin** (4)

		
		Te sugiero en general tratar de evitar inicializar el resultado con algo que no est√° presente en el arreglo.
		
		Lo m√°s conveniente ser√≠a inicializar con el primer elemento y empezar a comparar a partir del segundo.

* **Juli√°n David Cubillos Orteg√≥n** (1)

	
	Hola adjunto mi solucion al reto!!!
	``` 
	    #include<stdio.h>
	    #include<string.h>
	    #include<stdlib.h>
	    
	    typedefchar CADENA[100];
	    
	    struct CAD {
	    	CADENA cad1;
	    	CADENA cad2;
	    };
	    
	    voidllenado( struct CAD * cadena, constchar * cad1, constchar * cad2)
	    {
	    	if ((strlen(cad1)<100) && (strlen(cad2)<100))
	    	{
	    		strcpy(cadena->cad1, cad1);
	    		strcpy(cadena->cad2, cad2);
	    	}
	    	else
	    	{
	    		printf("Una de las dos cadenas supera los 100 caracteres \n");
	    	}
	    }
	    
	    intmain( int argc , constchar * argv[])
	    {
	    	struct CAD cadena;
	    	int long1;
	    	int long2;
	    
	    	if (argc <= 2 || argc > 3)
	    	{
	    		printf("La cantidad de cadenas o palabras a escribir son dos ni mas ni menos \n");
	    
	    		return1;
	    	}
	    
	    	llenado(&cadena, argv[1], argv[2]);
	    
	    	long1 = strlen(argv[1]);
	    	long2 = strlen(argv[2]);
	    
	    	if (long1 > long2)
	    	{
	    		printf("La cadena: %s es la mas larga\n", cadena.cad1);
	    	}
	    	elseif (long1 < long2)
	    	{
	    		printf ("La cadena: %s es la mas larga\n", cadena.cad2);
	    	}
	    	else
	    	{
	    		printf ("Las dos cadenas son iguales \n");
	    	}
	    
	    	return0;
	    }
	    
	```

* **Miguel Bedoya** (1)

	
	Hola a todos. A continuaci√≥n mi soluci√≥n:
	``` 
	    #include<stdio.h>
	    #include<stdlib.h>
	    #include<string.h>
	    
	    intmain( int argc, constchar * argv[] )
	    {
	            int i = 1;
	            char str_large[100];
	    
	            if ( argc > 2 )
	            {
	    
	                    while ( i < argc - 1 )
	                    {
	                            if ( strlen( argv[i] ) < strlen( argv[i + 1] ) )
	                            {
	                                    strcpy( str_large, argv[ i + 1] );
	                            } else {
	                                    strcpy( str_large, argv[ i] );
	                            }
	                            i++;
	                    }
	    
	                    printf( "La cadena de caracteres m√°s larga es: %s\n", str_large );
	            }
	    
	            else {
	                    printf( "Por favor ingrese al menos 2 cadenas de caracteres\n" );
	            }
	    
	    }```
	    
	```

* **Erick Lopez** (1)

	
	Aqui esta mi codigo del mismo desafio, ahora usando la creacion de librerias para cualquier numero de argumentos
	``` 
	    #ifndef MI_LIBRERIA
	    #define MI_LIBRERIA
	    	#include<stdio.h>
	    	#include<string.h>
	    	voidCadenaLarga(int posicion, constchar * cadena, constchar * cadena2);
	    	voidcadenaMasLarga(constchar * cadenaMasLarga);
	    	int P;
	    #endif
	    ----------------------------------------------------------------------
	    #include"23_miLibreria.h"
	    int P = 1;
	    voidCadenaLarga(int posicion, constchar * cadena, constchar * cadena2){
	    	if(strlen(cadena2) > strlen(cadena)){
	    		P = posicion+1;
	    	}
	    }
	    voidcadenaMasLarga(constchar * cadenaMasLarga){
	    	printf("la cadena mas larga es = %s \n", cadenaMasLarga);
	    }
	    ----------------------------------------------------------------------------------
	    #include"23_miLibreria.h"
	    intmain(int argc, constchar * argv[])
	    {
	    	for(int i = 1; i < (argc - 1); i++){
	    	CadenaLarga(i, argv[i], argv[i+1]);
	    	}
	    	cadenaMasLarga(argv[P]);
	    	return0;
	    }
	    
	```

* **Erick Lopez** (1)

	
	Desafio completado con el menor cantidad de codigo, para cualquier numero de cadenas ingresadas
	``` 
	    #include<stdio.h>
	    #include<string.h>
	    intmain(int argc, char * argv[]){
	    	int i = 1;
	    	for(int j = i+1; j < argc; j++){
	    		if(strlen(argv[j]) > strlen(argv[i])){
	    		i = j;
	    		}
	    	}
	    	printf("La cadena de mayor caracteres es = %s \n", argv[i]);
	    	return0;
	    }
	    
	    
	```
	
	![codigo.png](https://static.platzi.com/media/user_upload/codigo-d85b58ed-1a64-49d1-9b7e-3169c0137c7a.jpg)

* **Samuel Mauricio Braganza Zorilla** (1)

	```
	    #include<stdio.h>
	    #include<string.h>
	    #include<stdlib.h>
	    
	    intmain( int argc, constchar * argv[] )
	    {
	            if (argc < 2) {
	                    printf("Ingrese al menos una palabra, por favor!\n");
	                    return1;
	            }
	            char * cadena_mas_larga = "";
	            for (int i = 1; i < argc; i++ ) {
	                    if ( strlen(argv[i]) > strlen(cadena_mas_larga) ) {
	                            cadena_mas_larga = (char *) argv[i];
	                    }
	                    printf("cadena_mas_larga=%s (%p)\n", cadena_mas_larga, &cadena_mas_larga);
	            }
	            return0;
	    }```
	    
	```

* **david.lachealvarez** (1)

	
	El argumento de mayor tama√±o‚Ä¶!!
	``` 
	    #include<stdio.h>
	    #include<string.h>
	    
	    intmain(int argc, char *argv[]){
	        //Declaramos nuestra variable mayor
	        char *mayor = "";
	    
	        //Asignamos mayor a nuestro primer argumento
	        mayor = argv[1];
	        
	        for(int i=1; i<argc; i++){
	            // Comparamos cada elemento de la cadena e argumento con el mayor
	            if( strlen(argv[i]) > strlen(mayor)){  
	                mayor = argv[i];
	            }
	            
	            
	        }
	    
	        printf("El argumento de mayortama√±o es: %s \n", mayor);
	    
	        return0;
	    }```
	    
	```

* **paconity** (1)

	
	Por s√≠ hay m√°s de una cadena de caracteres que devolver, prefer√≠ no limitar al usuario de ninguna forma.
	``` 
	    #include <stdio.h>
	    #include <string.h>
	    
	    int main ( int argc, const char * argv[] ) {
	    
	            if ( argc < 3 ) {
	                    printf("\nIngrese m√≠nimo 2 cadenas de caracteres\n");
	    
	                    return1;
	            } else {
	                    char * max = argv[1];
	                    int moreMax[argc - 2];
	                    int x = 0;
	    
	                    for (int i = 2; i < argc; i++) {
	                            if (strlen(argv[i]) > strlen(max)) {
	                                    max = argv[i];
	                                    x = 0;
	                            } elseif (strlen(argv[i]) == strlen(max)) {
	                                    moreMax[x] = i;
	                                    x++;
	                            }
	                    }
	                    if (x) {
	                            printf("\n%s\n", max);
	    
	                            for (int i = 0; i < x; i++) {
	                                    printf("%s\n", argv[moreMax[i]]);
	                            }
	                    } else {
	                            printf("\n%s\n", max);
	                    }
	    
	            }
	    
	            return0;
	    }```
	    
	```

* **Cristian Rosales** (1)

	
	Reto Cumplido ‚úåüèº
	``` 
	    #include <stdio.h>
	    #include <string.h>
	    
	    int main(int argc, const char * argv[]){
	    
	            if(argc<3){
	                    printf("Escriba al menos dos cadenas de caracteres\n");
	                    return1;
	            }
	            int cmp = 0, var;
	    
	            for(int i=1; i<argc; i++){
	                    if(strlen(argv[i])>cmp){
	                            cmp=strlen(argv[i]);
	                            var = i;
	                    }
	            }
	            printf("La cadena de mayor longitud es: %s\n", argv[var]);
	    
	            return0;
	    }
	    
	```
	
	![reto2CLI.jpg](https://static.platzi.com/media/user_upload/reto2CLI-624034b2-f188-453f-8b1f-dc2f636f8f4a.jpg)

* **Luis Fernando Zarazua Aguilar** (1)

	```
	    #include <stdio.h> //Directiva de precompilador (inclusi√≥n de archivo).
	    #include <stdlib.h>
	    #include <string.h>
	    
	    char * CadenaMasLarga(int *num, char *argv[])
	    {
	        int indice=1,lenCadena=0,lmax=0,i;
	        for (i = 1; i < *num; i++)
	        {
	            lenCadena = strlen(argv[i]);
	            if (lmax < lenCadena)
	            {
	                lmax = lenCadena;
	                indice = i;
	            }
	        }
	        
	        return argv[indice];
	    }
	    
	    int main(int argc, char * argv[])
	    {
	        switch (argc)
	        {
	        case1:
	            printf("Sin elementos a comparar.");
	            break;
	        case2:
	            printf("La cadena mas larga es: %s", argv[1]);
	            break;
	        default:
	            printf("La cadena mas larga es: %s", CadenaMasLarga(&argc,argv));
	            break;
	        }
	        return0;
	    }```
	    
	```

* **AngelFA04** (1)

	```
	    /*Este programa recibe cadenas de caracteres de la linea de comandos y regresa la cadena m√°s larga */
	    #include<stdlib.h>
	    #include<stdio.h>
	    #include<string.h>
	    
	    intgreatestString(int len, char **arr){
	        int maxIndex = 1;
	        char * maxWord = arr[maxIndex];
	        for(int i = 1; i < len; i++){
	            printf("Cadena arr[%i] = %s, len = %li\n", i, arr[i], strlen(arr[i]));
	            if (strlen(arr[i]) > strlen(arr[maxIndex])){
	                maxIndex = i;
	            }
	    
	        }
	        return maxIndex;
	    }
	    
	    
	    intmain(int argc, char **argv)
	    {
	        int indexGreatest = greatestString(argc, argv);
	        printf("La palabra m√°s grande es: %s\n", argv[indexGreatest]);
	        return0;
	    }
	    
	    
	```

* **Alfredo Gonzalez** (1)

	
	![](![Screen Shot 2020-03-08 at 23.47.49.png](https://static.platzi.com/media/user_upload/Screen%20Shot%202020-03-08%20at%2023.47.49-35f9a00f-5ffe-41c6-9ee0-2fd37c380757.jpg)

* **Miguel Angel** (1)

	
	RETO
	``` 
	    #include<stdio.h>
	    #include<string.h>
	    int main(int argc, const char * argv[]){
	      int longer=0,pos;
	      for(int i=1;i<argc;i++){
	        if(longer<strlen(argv[i])){
	          longer=strlen(argv[i]);
	          pos=i;
	        }
	      }
	      printf("The longest word is : %s",argv[pos]);
	    }```
	    
	```

* **jimezam** (1)
Esperaba que se creara una bibliiteca est√°tica (.a) o una din√°mica (.so).

* **Lery Andy Pi√©rola Lazarte** (1)

	```
	    #include<stdio.h>
	    #include<string.h>
	    
	    intmain( int argc, constchar * argv[])
	    {
	     
	     int l1 = strlen(argv[1]);
	     int l2 = strlen(argv[2]);
	    
	       if ( l1 > l2 ) 
	       {
	            printf("La cadena mas grande es: %s\n", argv[1]);
	       }
	       else
	       {
	            printf("La cadena mas grande es: %s\n", argv[2]);
	       }
	       
	        return0;
	    }```
	    
	```

* **guillermogranado** (1)

	
	Soluci√≥n al desafio:
	``` 
	    #include <stdio.h>
	    #include <string.h>
	    
	    int main(int argc, const char * argv[]) {
	    
	        if (argc < 2) {
	            printf("None string was included\n");
	            return1;
	        }
	    
	        int max_length_counted = 0;
	        int longest_string_index = 0;
	    
	        int string_length = 0;
	        for (int i = 1; i < argc; i++) {
	            string_length = strlen(argv[i]);
	            if (string_length > max_length_counted) {
	                max_length_counted = string_length;
	                longest_string_index = i;
	            }
	        }
	    
	        if (longest_string_index > 0) {
	            printf("The longest string was: %s\n", argv[longest_string_index]);
	        }
	        return0;
	    }
	    
	```

* **Juan Camilo Alvarez Jurado** (1)

	
	Mi soluci√≥n al desaf√≠o:
	
	![](![Desafio1.png](https://static.platzi.com/media/user_upload/Desafio1-6cfa4e8a-d510-4ef5-999b-7e557d8e7329.jpg)

	* **ffranco_** (2)

		
		Eres un crack üòÑ. Trat√© de hacerlo con el m√©todo de la burbuja, pero no se me hab√≠a ocurrido solo guardar el √≠ndice mayor. Gracias por compartir tu soluci√≥n.

* **David Felipe Boh√≥rquez** (1)
Quise aplicar otros temas vistos en el curso, sin embargo aqui veo un error curioso (probablemente por novato) Al pasar argumentos inferi...

	* **Ivan Rene Acosta Lallemand** (1)

		
		Amigo si escribiste el c√≥digo tal cual lo pegaste aqui es un tema de espacios, lo probe con el formateo adecuado y realizo la impresi√≥n que quer√≠as.
		
		Pego la manera en como me funciono y revises la parte de los espacios.
		``` 
		    #include<stdio.h>
		    #include<string.h>
		    
		    voidcompareChars(int argcx, char * argvx[]){
		    	
		    	
		    
		    	char longest_string[100];
		    	strcpy(longest_string,argvx[0]);
		    	
		    
		    	for(int i = 0; i < argcx; i++)
		    	{
		    		if(strlen(longest_string) < strlen(argvx[i])){
		    			strcpy(longest_string, argvx[i]);
		    		}
		    
		    	}
		    
		    	printf("La cadena de chars mas larga es = %s\n", longest_string);
		    
		    }
		    
		    
		    intmain(int argc, char * argv[])
		    {
		    	
		    	
		    	compareChars(argc, &argv[0]);
		    
		    	
		    
		    
		    	return0;
		    }
		    
		```

* **Jordan Ronaldo Buitrago Sandoval** (0)

	```
	    /*header file*/
	    
	    #ifndef _HEADER_
	    #define _HEADER_
	    
	    #include<stdio.h>
	    #include<string.h>
	    voidprintLargestString(int arc, char *arv[]);
	    
	    #endif
	    
	    
	    /*print larget string function*/
	    
	    #include"header.h"
	    voidprintLargestString(int arc, char *arv[])
	    {
	            int i= 1, temp = 0, total = 0;
	            char largest[50];
	    
	            for (; i < arc; i++)
	            {
	                    temp = strlen(arv[i]);
	                    if(temp > total)
	                    {
	                            total = temp;
	                            strcpy(largest, arv[i]);
	                    }
	            }
	    
	            printf("largest: %s\n", largest);
	    }
	    
	    
	    /*main function */
	    
	    #include"header.h"
	    intmain(int argc, char *argv[])
	    {
	            int arc = argc;
	    
	            if (argc ==  1)
	            {
	                    printf("ingrese cadenas de texto a ser comaparadas\n");
	                    return (1);
	            }
	    
	            printLargestString(argc, argv);
	            return (0);
	    }```
	    
	```

# Comprender los desaf√¨os de la administraci√≥n de la memoria

## 0200. Manejo din√°mico de la memoria

### Descripci√≥n:


### Comentarios:

* **Abdel Mejia** (4)

	
	Aclaraci√≥n
	``` 
	    sizeof
	    
	```
	
	**No es una funci√≥n, es un operador unario**
	
	[Mas informaci√≥n](https://stackoverflow.com/a/1393592)

* **onyx** (1)

	
	Archivo de libreria:  
	lib.h
	``` 
	    #ifndef _LIB_H
	    #define _LIB_H
	    
	    #include<stdio.h>
	    
	    voiddisplay_help()
	    {
	        printf(" - this program compare two or more strings\n");
	        printf("   and display the first longest one\n");
	    }
	    
	    intlen(char *s)
	    {
	        return ((!*s) ? 0 : 1 + len(s + 1));
	    }
	    
	    #enddef /* _LIB_H */
	    
	```
	
	programa principal  
	main.c
	``` 
	    #include<stdio.h>
	    #include"lib.h"
	    
	    intmain(int ac, char **av)
	    {
	        char *out = "";
	        
	        if (ac < 2)
	            display_help();
	        else
	        {
	            for (av++; *av; av++)
	                out = (len(*av) > len(out)) ? *av : out;
	            
	            printf("The longest one is \"%s\"\n", out);
	        }
	        
	        return0;
	    }
	    
	```

* **jimezam** (1)
¬øPoner los alias de los tipos de datos en may√∫sculas obedece a alg√∫n est√°ndar de nomenclatura?

	* **Jeffersson Mu√±oz Torres** (1)

		
		En muchos lenguajes de programaci√≥n, no estoy seguro si en C se cumple, las variables con letras may√∫sculas se consideran constantes.

* **Sebastian Augusto Baez Ramos** (0)
las funciones malloc y realloc,¬øsiguen siendo pr√°cticas en POO?

	* **ricardocelis (Platzi)** (3)

		
		no realmente, son conceptos y utilizades pensadas para enfoques distintos.

## 0210. C√≥mo instalar Valgrind

### Descripci√≥n:


Valgrind es una herramienta que te ayudar√° a descubrir los memory leaks que puede haber en tus aplicaciones.

Para poder utilizarla necesitas tenerla instalada en tu computador.

Las instrucciones precisas dependen del sistema operativo que utilices pero te dar√© una idea general que podr√°s adaptar en caso de que tu entorno no sea exactamente igual al m√≠o.

# C√≥mo instalar Valgrind en Ubuntu

El caso m√°s sencillo de instalaci√≥n es si est√°s utilizando Ubuntu (Si se trata de la versi√≥n embebida en Windows tambi√©n aplica).

  1. Abre una consola

![abrir una consola.png](https://static.platzi.com/media/user_upload/abrir%20una%20consola-d5a8a351-c75d-4c0d-84ca-68e3a88a941c.jpg)

  2. Actualiza tu administrador de paquetes (Ingresa tu contrase√±a cuando se te solicite).  
![actualiza tu administrador de paquetes.png](https://static.platzi.com/media/user_upload/actualiza%20tu%20administrador%20de%20paquetes-ef8e6df4-0cb7-43b4-93c1-bbaa387eba72.jpg)



Deber√≠as llegar a algo parecido a

![parecido a .png](https://static.platzi.com/media/user_upload/parecido%20a%20-3e79ceeb-e89e-40bc-8f4e-19efdee7498b.jpg)

  3. Instala Valgrind usando sudo apt install Valgrind (Ingresa tu contrase√±a cuando se te solicite)

![instala valgrind.png](https://static.platzi.com/media/user_upload/instala%20valgrind-46c02b78-b0d9-41a3-8c2c-14c23911c3ff.jpg)

  4. Contesta s√≠  
![contesta siÃÅ.png](https://static.platzi.com/media/user_upload/contesta%20si%CC%81-f429b8d6-3cb1-4106-9421-ba5d8376bbde.jpg)

  5. Utiliza el comando `valgrind --help` para validar que la instalaci√≥n fue exitosa




## C√≥mo instalar Valgrind en otras distribuciones

Lo ideal es que instales directamente el binario que tu administrador de paquetes proponga, claro que si no dispones de uno, siempre podr√°s compilar el c√≥digo por tus propios medios.

  1. Instala las herramientas gcc y make

  2. Descarga la √∫ltima versi√≥n correspondiente a tu plataforma desde <http://valgrind.org/downloads/current.html>

  3. Extrae el archivo comprimido

  4. Realiza la compilaci√≥n

  5. Ejecuta cmake

  6. Ejecuta make

  7. Verifica tu instalaci√≥n usando el comando ‚Äò‚Äòvalgrand --help‚Äô‚Äô




## C√≥mo ejecutar Valgrind

Una vez lo tengas instalado podr√°s usar Valgrind como vimos en el curso: s√≥lo necesitas ejecutar valgrind seguido del comando que usar√≠as para correr tu programa normalmente.

No hay excusas, ¬°que no quede un s√≥lo leak dando vueltas!

![actualiza tu administrador de paquetes.png](https://static.platzi.com/media/user_upload/actualiza%20tu%20administrador%20de%20paquetes-21d8695e-f214-4d0f-a62f-ce4f01dd5203.jpg)

### Comentarios:

* **ppastram** (1)

	
	Alguien sabe c√≥mo instalar valgrind en MacOS Catalina?

	* **paconity** (1)

		
		En la p√°gina de Valgrind dice que hay compatibilidad hasta el macOs 10.13 o sea High Sierra, aunque no aplique en este caso te recomiendo usar Homebrew para este tipo de programas.

* **David Felipe Boh√≥rquez** (1)

	
	En Fedora 31 tambi√©n se puede instalar con un ‚Äúsudo dnf install valgrind‚Äù

## 0220. Memory leaks y Garbage Collectors

### Descripci√≥n:


### Links:

* [Valgrind Home](http://valgrind.org/)

### Comentarios:

* **jimezam** (1)
Seg√∫n este ejemplo, ¬øel "return 0" del main es opcional aunque √©ste sea int?

	* **Yael Badillo** (1)

		
		S√≠, pero es recomendable ponerlo por buena pr√°ctica.

* **Sebastian Augusto Baez Ramos** (0)
No he podido instalar Valgrind. Ya descomprim√≠ el archivo, pero no s√© que hay que hacer con todas esas carpetas

	* **Mauro Chojrin** (2)

		
		¬øQu√© sistema operativo usas? Chequea si tienes un archivo Makefile.
		
		Si descargaste los fuentes vas a tener que compilar e instalar por tus propios medios‚Ä¶

## 0230. Listas enlazadas

### Descripci√≥n:


### Comentarios:

## 0240. Ejercicio pr√°ctico de listas enlazadas

### Descripci√≥n:


### Comentarios:

* **Jordan Ronaldo Buitrago Sandoval** (6)

	```
	    /*Cuando hacemos malloc es bueno hacer un test para saber si es null tal resultado*/
	    newNode = malloc(sizeof(NODE));
	    if (newNode == NULL)
	    	returnNULL;
	    
	    /*awesome trick*/
	    printf(current->next ? ", " : "\n" );
	    
	```

* **Luis Fernando Zarazua Aguilar** (2)

	
	La instrucci√≥n malloc es un muy parecida a new en orientado a objetos.

	* **Franco Bottazzi** (1)

		
		Con orientado a objetos no s√© si te refer√≠s al uso de new en c++ o en cosas como Javascript, si es el primero si, de hecho new es el reemplazo que se le hizo a malloc (que hace la asignaci√≥n de memoria m√°s f√°cil y elegante), en el caso de Javascript no es as√≠, el new en Js est√° para reemplazar al constructor, porque como las variables pueden tener cualquier tipo de dato, no se usa el constructor abriendo y cerrando par√©ntesis despu√©s del nombre de la variable.

## 0250. Liberando las listas enlazadas

### Descripci√≥n:


### Links:

* [Curso B√°sico de Algoritmos | Platzi](https://platzi.com/clases/algoritmos/)

### Comentarios:

* **Mauricio David Cuello Alzate** (1)

	
	Hola  
	Como se copia y pega en vim?

	* **jose luis gonzalez aguilera** (1)

		
		hola, aqui un link <https://blog.carreralinux.com.ar/2017/09/copiar-y-pegar-con-vim-cortar-deshacer/>

* **Jean Carlos Nu√±ez Hernandez** (1)

	
	liberar memoria es importante cuando se trabaja con las lista enlazadas

## 0260. Reto Modifica el programa para que permita eliminar los nodos en los que se encuentre un determinado n√∫mero

### Descripci√≥n:


Partiendo del c√≥digo que se encuentra en <https://raw.githubusercontent.com/mchojrin/platzi_curso_c_clases/2b66b7e0178c0ae13c9434e3bf9eb08a8aad0434/linked_list.c> realiza las modificaciones necesarias para poder eliminar nodos.

### Tips

Suponiendo que la lista est√° de esta forma:

![start 1.png](https://static.platzi.com/media/user_upload/start%201-e93146b8-1213-48d2-b380-70958812e5d5.jpg)

Nos encontramos con estos casos:

  1. El nodo que queremos eliminar no existe

  2. El nodo que queremos eliminar no es el primero

  3. El nodo que queremos eliminar es el primero




### Si el nodo no existe

Este es el caso m√°s simple, s√≥lo se recorrer√° la lista y quedar√° igual que al comienzo.

### Si el nodo **no** es el primero

![no es el primero.png](https://static.platzi.com/media/user_upload/no%20es%20el%20primero-5cf4ecb0-dde8-4c0c-96b8-9a79af1d9533.jpg)

En este caso tendremos que saber siempre cu√°l era el nodo anterior para, una vez eliminado el buscado, apuntar el siguiente del anterior al siguiente del eliminado.

### Si el nodo es el primero

![si el nodo es el primero.png](https://static.platzi.com/media/user_upload/si%20el%20nodo%20es%20el%20primero-bb6d6a15-6697-43a4-8000-e9e7b9a815ad.jpg)

Este es un caso especial por dos razones:

  1. No existe un nodo anterior

  2. Al finalizar la eliminaci√≥n tambi√©n deberemos modificar el comienzo de la lista




Tu tarea: escribir el c√≥digo!

### Comentarios:

* **alepaper** (2)

	```
	    #include <stdio.h>
	    #include <stdlib.h>
	    
	    typedef struct Node {
	        int number;
	        struct Node * next;
	    } NODE;
	    
	    NODE * createNode( int number )
	    {
	        NODE * newNode;
	    
	        newNode = malloc( sizeof(NODE) );
	        newNode->next = NULL;
	        newNode->number = number;
	    
	        return newNode;
	    }
	    
	    void deleteNode(int number, NODE * * start, int * cant){
	        if(number && *start){
	            NODE * current, * prev = NULL;
	            current = *start;
	            do{
	                if (current->number == number)
	                {
	                    if(!prev){
	                        *start = current->next;
	                        free(current);
	                        current = *start;
	                        (*cant)--;
	                        if(!*start){
	                            break;
	                        }
	                    }
	                    else
	                    {
	                        prev->next = current->next;
	                        free(current);
	                        current = prev->next;
	                        (*cant)--;
	                    }
	                }
	                else
	                {
	                    prev = current;
	                    current = current->next;
	                }
	            } while ( current );
	        }
	        
	    }
	    
	    int main( int argc, const char * arg[] )
	    {
	        NODE * start = NULL, * current, * next;
	        char goOn;
	        int listSize = 0, number;
	        do {
	            printf( "La lista contiene %d nodos. Ingrese el siguiente numero (0 para finalizar)\n", listSize );
	            scanf("%d", &number );
	            if ( number ) {
	                if ( !start ) {
	                    start = createNode( number );
	                } else {
	                    current = start;
	                    while ( current->next ) {
	                        current = current->next;
	                    }
	                    current->next = createNode( number );
	                }
	                listSize++;
	                goOn = 1;
	            } else {
	                goOn = 0;
	            }
	        } while ( goOn );
	    
	        current = start;
	        printf( "La lista contiene los numeros: \n" );
	        while (current) {
	            printf( "%d", current->number );
	            printf( current->next ? ", " : "\n" );
	            current = current->next;
	        }
	    
	        printf( "La lista contiene %d nodos. Ingrese el n√∫mero a eliminar (0 para finalizar)\n", listSize );
	        scanf("%d", &number );
	        if ( number ) {
	            deleteNode(number,&start, &listSize);
	        }
	    
	        current = start;
	        printf( "La lista contiene %d nodos con los numeros: \n",listSize);
	        while (current) {
	            printf( "%d", current->number );
	            printf( current->next ? ", " : "\n" );
	            current = current->next;
	        }
	    
	        current = start;
	        while (current) {
	            next = current->next;
	            free(current);
	            current = next;
	        }
	    
	        return0;
	    }
	    
	    
	```

* **Juan Camilo Alvarez Jurado** (2)

	
	Mi soluci√≥n:
	``` 
	    #include <stdio.h>
	    #include <stdlib.h>
	    
	    typedef struct Node {
	        int number;
	        struct Node * next;
	    } NODE;
	    
	    NODE * createNode( int number )
	    {
	        NODE * newNode;
	    
	        newNode = malloc( sizeof(NODE) );
	        newNode->next = NULL;
	        newNode->number = number;
	    
	        return newNode;
	    }
	    
	    NODE * deleteNode( NODE * list, int number ) {
	        NODE * aux = list;
	    
	        if (aux->number == number) {
	            list = aux->next;
	    
	            free(aux);
	        }
	        else {
	            while(aux->next->number != number)
	                aux = aux->next;
	    
	            NODE * toDelete = aux->next;
	    
	            aux->next = aux->next->next;
	    
	            free(toDelete);
	        }
	    
	        return list;
	    }
	    
	    int main( int argc, const char * arg[] )
	    {
	        NODE * start = NULL, * current, *next;
	        char goOn;
	        int listSize = 0, number;
	    
	        do {
	            printf( "La lista contiene %d nodos. Ingrese el siguiente numero (0 para finalizar)\n", listSize );
	            scanf("%d", &number );
	            if ( number ) {
	                if ( !start ) {
	                    start = createNode( number );
	                    listSize++;
	                } else {
	                    current = start;
	                    while ( current->next ) {
	                        current = current->next;
	                    }
	                    current->next = createNode( number );
	                    listSize++;
	                }
	                goOn = 1;
	            } else {
	                goOn = 0;
	            }
	        } while ( goOn );
	    
	        current = start;
	        printf( "La lista contiene los numeros: \n" );
	        while (current) {
	            printf( "%d", current->number );
	            printf( current->next ? ", " : "\n" );
	            current = current->next;
	        }
	    
	        int nodoABorrar;
	    
	        printf("Por favor ingrese el numero de nodo a borrar: ");
	        scanf("%d",&nodoABorrar);
	    
	    
	        printf("Vamos a borrar el nodo con numero %d\n",nodoABorrar);
	        start = deleteNode(start,nodoABorrar);
	        current = start;
	    
	        printf( "La lista queda asi: \n" );
	        while (current) {
	            printf( "%d", current->number );
	            printf( current->next ? ", " : "\n" );
	            current = current->next;
	        }
	    
	        current = start;
	        while (current) {
	            next = current->next;
	            free( current );
	            current = next;
	        }
	    
	        return0;
	    }
	    
	```

* **Cristian Rosales** (1)

	
	¬°Tarea cumplida!‚úåüèº
	
	Aqu√≠ estan las dos funciones que hacen el trabajo, lo dem√°s es carpinteria.
	``` 
	    int deleteNode(NODE* node, NODE** start){
	            int number;
	            if(node->next){
	                    //El nodo a eliminar no es el primero
	                    if(node->previous){
	                            node->previous->next = node->next;
	                            node->next->previous = node->previous;
	                    }else{
	                            //El nodo a eliminar es el pirmero
	                            *start = node->next;
	                            (*start)->previous = NULL;
	                    }
	            }else{
	                    //El nodo a eliminar es el ultimo
	                    if(node->previous){
	                            node->previous->next = NULL;
	                    }else{//Solo queda un nodo
	                            *start = NULL;
	                    }
	            }
	            number = node->number;
	            free(node);
	            returnnumber;
	    }
	    void findNode(int number, NODE** start){
	            NODE* current = *start;
	            int band=0;
	            while(current){
	                    if(current->number == number){
	                            band = deleteNode(current, start);
	                            break;
	                    }
	                    current = current->next;
	            }
	            if(band){
	                    printf("Numero %d eliminado exitosamente!\n", band);
	            }else{
	                    printf("No se encontr√≥ el numero en la lista\n");
	            }
	    }
	    
	```
	
	![Anotaci√≥n 2020-03-31 230751.jpg](https://static.platzi.com/media/user_upload/Anotaci%C3%B3n%202020-03-31%20230751-36b98c42-e4d0-484a-80c3-8dcf9c865cab.jpg)

* **Luis Fernando Zarazua Aguilar** (1)

	```
	    void EliminarNodo(int nodeNumber, NODE **startPtr, int *listSize)
	    {
	        NODE *start, *pastnode, *deletednode;
	        if (nodeNumber <= *listSize && nodeNumber > 0) //Si esta fuera del limite solo muestra (no hace cambios).
	        {
	            start = *startPtr;   //Guarda el puntero al inicio de la lista.
	            if (nodeNumber == 1) //Si es el primer nodo.
	            {
	                *startPtr = start->next; //Hace que el segundo nodo ahora sea el primero.
	                free(start);             //Libera de memoria el nodo eliminado.
	            }
	            else//Si es un nodo de en medio
	            {
	                pastnode = start; //Se comienza en el nodo origen.
	                for (int i = 1; i < nodeNumber - 1; i++)
	                {
	                    pastnode = pastnode->next; //Avanza hasta el nodo anterior al que se quiere eliminar.
	                }
	                deletednode = pastnode->next;       //Obtiene el nodo que se quiere eliminar.
	                pastnode->next = deletednode->next; //Se cambia la direcci√≥n del eliminado por el siguiente del eliminado.
	                free(deletednode);                  //Libera de memoria el nodo eliminado.
	            }
	            *listSize = *listSize - 1;
	        }
	    }```
	    
	```

* **Valakyr** (1)
![Linked_list_delete.png](https://static.platzi.com/media/user_upload/Linked_list_delete-7d35cdb6-e69c-459d-b64f-fa15bbf1981f.jpg)

* **gnbarzol** (1)

	
	Tarea cumplida!
	``` 
	    #include <stdio.h>
	    #include <stdlib.h>
	    
	    typedef struct Node{
	        int number;
	        struct Node * next;
	    } NODE;
	    
	    NODE * createNode( int number){
	        NODE * newNode;
	        newNode = malloc( sizeof(NODE));
	        (*newNode).number = number;
	        newNode->next = NULL;
	    
	        return newNode; 
	    }
	    
	    int main( int argc , const char * argv[]){
	    
	        NODE * start = NULL, * current, * next;
	        int goOn, listSize = 0, number;
	    
	        do{
	    
	            printf("1. Agregar un elemento a la lista\n");
	            printf("2. Remover un elemento de la lista\n");
	            printf("3. Mostrar Lista\n");
	            printf("4. Salir\n");
	            scanf("%d", &goOn);
	    
	            switch (goOn){
	                case1:
	                    printf("Ingrese el numero a a√±adir:\n");
	                    scanf("%d", &number);
	    
	                    if( number ){ //Quiere decir que "number" sea distinto de cero
	                        if( !start ){ //Si start es null
	                            start = createNode(number);
	                        }else{
	                            current = start;
	                            while( current -> next ){
	                                current = current->next;
	                            }
	                            current->next = createNode(number);
	                        }
	                        listSize++;
	                    }else{
	                        printf("Debe ingresar un numero distinto de cero.\n");  
	                    }
	                    break;
	    
	                case2:
	                    printf("Escriba el numero a eliminar: \n");
	                    scanf("%d", &number);
	         
	                    if(start->number == number){ //Caso base: es que el elemento sea el primero
	                        next = start->next;
	                        start = NULL;
	                        start = next;
	                    }else{ 
	                        current = start; 
	                        while(current){ //Recorrera toda la lista en busca del Node.
	                            if(current->next->number == number){
	                                next = current->next->next;
	                                current->next= NULL;
	                                current->next = next;
	                                break;
	                            }else{
	                                current = current->next;
	                            } 
	                        }
	                    }
	                    break;
	                case3:
	                    current = start;
	                    printf("La lista contiene los numeros: \n");
	    
	                    while( current ){
	                        printf("%d",current->number);
	                        printf( current->next ? "," : "\n");
	                        current = current->next;
	                    }
	                    break;
	                case4:
	                    goOn = 0;
	                    break;
	            }
	        }while(goOn);
	    
	        //Liberamos la memoria.
	        current = start;
	        while(current){
	            next = current->next;
	            free(current);
	            current = next;
	        }
	    
	        return0;
	    }
	    
	```

* **EPadronU23** (1)

	
	**Todo bien organizado y legible**
	``` 
	    /* Libraries ********************************************************/
	    #include <stdlib.h>
	    #include <stdio.h>
	    /********************************************************************/
	    
	    /* Types ************************************************************/
	    typedef int CONTENT;
	    
	    typedef struct node {
	      CONTENT content;
	      struct node* next;
	    } NODE;
	    
	    typedef struct {
	      long size;
	      NODE* head;
	      NODE* tail;
	    } LINKED_LIST;
	    /********************************************************************/
	    
	    /* Functions ********************************************************/
	    LINKED_LIST* linked_list_init() {
	      LINKED_LIST* list = malloc(sizeof(LINKED_LIST));
	    
	      list->size = 0;
	      list->head = NULL;
	      list->tail = NULL;
	    
	      return list;
	    }
	    
	    void linked_list_free(LINKED_LIST* list) {
	      NODE* current = list->head;
	      NODE* next = NULL;
	    
	      while (current) {
	        next = current->next;
	        free(current);
	        current = next;
	      }
	    
	      free(list);
	      list = NULL;
	    }
	    
	    void linked_list_traverse(const LINKED_LIST* list, void onNode(const NODE* node)) {
	      const NODE* current = list->head;
	    
	      while (current) {
	        onNode(current);
	        current = current->next;
	      }
	    }
	    
	    int linked_list_append(LINKED_LIST* list, const CONTENT newContent) {
	      NODE* newNode = malloc(sizeof(NODE));
	    
	      newNode->content = newContent;
	      newNode->next = NULL;
	    
	      if (!list->head) {
	        list->head = newNode;
	        list->tail = newNode;
	      } else {
	        list->tail->next = newNode;
	        list->tail = newNode;
	      }
	    
	      return ++list->size;
	    }
	    
	    int linked_list_remove(LINKED_LIST* list, const CONTENT content) {
	      NODE* current = list->head;
	      NODE* previous = NULL;
	    
	      while (current) {
	        if (current->content == content) {
	          if (current == list->head){
	            list->head = list->head->next;
	          } else {
	            previous->next = current->next;
	          }
	    
	          if (!previous) {
	            list->tail = list->head;
	          } elseif (!previous->next) {
	            list->tail = previous;
	          }
	    
	          free(current);
	    
	          list->size--;
	    
	          return1;
	        }
	    
	        previous = current;
	        current = current->next;
	      }
	    
	      return0;
	    }
	    
	    void int_node_print(const NODE* node) {
	      if (node) {
	        printf(" %d ", node->content);
	      }
	    }
	    /********************************************************************/
	    
	    /* Main *************************************************************/
	    int main() {
	      LINKED_LIST* myList = linked_list_init();
	    
	      printf("Just initialized: %ld ->", myList->size);
	      linked_list_traverse(myList, int_node_print);
	    
	      for (int i = 1; i <= 10; i++) {
	        linked_list_append(myList, i);
	      }
	    
	      printf("\nAfter appending 1 to 10: %ld ->", myList->size);
	      linked_list_traverse(myList, int_node_print);
	    
	      for (int i = 2; i <= 10; i += 2) {
	        linked_list_remove(myList, i);
	      }
	    
	      printf("\nAfter removing all even numbers: %ld ->", myList->size);
	      linked_list_traverse(myList, int_node_print);
	    
	      for (int i = 1; i <= 10; i += 2) {
	        linked_list_remove(myList, i);
	      }
	    
	      printf("\nAfter removing all odd numbers: %ld ->", myList->size);
	      linked_list_traverse(myList, int_node_print);
	    
	      for (int i = 10; i >= 1; i--) {
	        linked_list_append(myList, i);
	      }
	    
	      printf("\nAfter appending 10 down to 1: %ld ->", myList->size);
	      linked_list_traverse(myList, int_node_print);
	    
	      linked_list_remove(myList, 5);
	    
	      printf("\nAfter removing 5: %ld ->", myList->size);
	      linked_list_traverse(myList, int_node_print);
	    
	      linked_list_append(myList, 5);
	    
	      printf("\nAfter appending 5 again: %ld ->", myList->size);
	      linked_list_traverse(myList, int_node_print);
	    
	      linked_list_free(myList);
	    
	      return0;
	    }
	    /********************************************************************/
	    
	```
	``` 
	    Just initialized: 0 ->
	    After appending 1 to 10: 10 -> 1  2  3  4  5  6  7  8  9  10
	    After removing all even numbers: 5 -> 1  3  5  7  9
	    After removing all odd numbers: 0 ->
	    After appending 10 down to 1: 10 -> 10  9  8  7  6  5  4  3  2  1
	    After removing 5: 9 -> 10  9  8  7  6  4  3  2  1
	    After appending 5 again: 10 -> 10  9  8  7  6  4  3  2  1  5
	    
	```

* **ffranco_** (1)

	
	Vaya l√≠o. Primero trat√© de pensar en una forma de resolverlo sin ver el tip y llegue a a√±adir estas l√≠neas de c√≥digo:
	``` 
	    printf ("Se tienen los nodos del 0 al %d.\n", listSize - 1);
	        printf ("Desea eliminar alguno de los %d nodos? (y): ", listSize);
	        char ans;
	    	scanf ("\n%c", &ans);
	        int theNode, i = 0;
	        if (ans == 'y' || ans == 'Y')
	        {
	            printf ("Nodo a eliminar: "); scanf ("%d", &theNode);
	            if (theNode >= 0 && theNode < listSize)
	            {
	                current = start;
	                while (i < theNode)
	                {
	    				aux = current;
	                    current = current -> next;
	                    i++;
	                }
	    			// En este momento current es el nodo a eliminar.
	    			// Por si se desea eliminar el √∫ltimo nodo, aux es el anterior a este.
	    			while (current -> next)
	    			{
	    				aux = current;
	    				current -> number = (current -> next) -> number;
	    				current = current -> next;
	    			} 
	    			// Current ahora contiene la direccion de memoria de la √∫ltima variable y aux la direccion anterior.
	    			aux -> next = NULL;
	    			free (current);
	    			listSize--;
	    			printf ("Nodo liberado.\n");
	            }
	            else
	            {
	                printf ("El nodo no se pudo encontrar.\n");
	            }
	    
	```
	
	La idea era ir moviendo los datos hasta que el √∫ltimo nodo quede vac√≠o y luego eliminar el √∫ltimo nodo. Sin embargo una vez vi el tip entend√≠ que hab√≠a una forma mucho m√°s eficaz. Realizando las modificaciones al c√≥digo anterior qued√≥:
	``` 
	    printf ("Se tienen los nodos del 0 al %d.\n", listSize - 1);
	        printf ("Desea eliminar alguno de los %d nodos? (y): ", listSize);
	        char ans;
	    	scanf ("\n%c", &ans);
	        int theNode, i = 0;
	        if (ans == 'y' || ans == 'Y')
	        {
	            printf ("Nodo a eliminar: "); scanf ("%d", &theNode);
	            if (theNode >= 0 && theNode < listSize)
	            {
	                current = start;
	                while (i < theNode)
	                {
	    				aux = current;
	                    current = current -> next;
	                    i++;
	                }
	    			if (theNode > 0)
	    			{
	    				aux -> next = current -> next;
	    			}
	    			else
	    			{
	    				start = current -> next;	
	    			}
	    			free (current);
	    			listSize--;
	    			printf ("Nodo liberado.\n");
	            }
	            else
	            {
	                printf ("El nodo no se pudo encontrar.\n");
	            }
	        }
	    
	```
	
	Es realmente genial que el profesor haya aportado su soluci√≥n y as√≠ abrir nuestra mente a nuevas y mejores opciones üòÉ

* **LuqueDaniel** (1)

	
	Crear una funci√≥n que se encargue de eliminar el elemento deseado.
	``` 
	    voidDeleteNode(NODE** start, int number)
	    {
	    	// Guardamos la direcci√≥n de memoria que contiene start
	    	NODE** prev = start;
	    	NODE* current = *start;
	    
	    	while (current)
	    	{
	    		if (current->number == number)
	    		{
	    			*prev = current->next;
	    			free(current);
	    			break;
	    		}
	    
	    		prev = &current->next;
	    		current = current->next;
	    	}
	    }
	    
	```
	
	Llamar a la funci√≥n pasando como primer par√°metro la direcci√≥n de memoria del puntero `start`, y el n√∫mero a eliminar como segundo.
	``` 
	    DeleteNode(&start, number);
	    
	```

* **onyx** (1)

	
	Solucion elimina el primer nodo que sea compatible con el nodo buscado  
	Retorna 1 si no termino de iterar la lista, si no 0  
	Podria usarse con un loop, para eliminar todos lo nodos del tipo buscado en la lista
	``` 
	    #include <stdlib.h>
	    
	    int delete_node(NODE **list, int data)
	    {
	      NODE *current = *list;
	      NODE *prev;
	      intcnt = 0;
	    
	      for (; current; current = current->next, cnt++)
	      {
	        if (current->number == data)
	        {
	          if (!cnt)
	            *list = current->next;
	          else
	            prev->next = current->next;
	          free(current);
	          break;
	        }
	        prev = current;
	      }
	    
	      return (current) ? 1 : 0;
	    }
	    
	```

* **Gustavo Mar√≠n** (1)

	
	Mi soluci√≥n
	``` 
	    #include <stdio.h>
	    #include <stdlib.h>
	    
	    typedef struct Node{
	    	int number;
	    	struct Node * next;
	    } NODE;
	    
	    NODE * createNode( int number){
	    	NODE * newNode;
	    	
	    	newNode = malloc( sizeof(NODE) );
	    	newNode->next = NULL;
	    	newNode->number = number;
	    
	    	return newNode;
	    }
	    
	    int main( int argc, const char * argv[] ){
	    	NODE * start = NULL, * current = NULL, * next;
	    	char goOn;
	    	int listsize = 0, number, node;
	    
	    	do{
	    		printf("La lista contiene %d nodos. Ingrese el siguiente n√∫mero (0 para finalizar)\n", listsize);
	    		scanf( "%d",&number );
	    		if(number){
	    			if(!start){
	    				start = createNode(number);
	    				listsize++;
	    			} else{
	    				current = start;
	    				while(current->next){
	    					current = current->next;
	    				}
	    				current->next = createNode( number );
	    				listsize++; 
	    			}
	    			goOn = 1;
	    		} else{
	    			goOn = 0;
	    		}
	    	} while( goOn );
	    	
	    	current = start;
	    	printf("La lista contiene los numeros: \n");
	    	while( current ){
	    		printf("%d", current->number);
	    		printf( current->next ? ", " : "\n" );
	    		current =  current->next;
	    	}
	    
	    	do{
	    		current = start;
	    		printf("Para borrar un n√∫mero de la lista indique la posicion (0 para omitir este paso):");
	    		scanf("%d", &node);
	    		if( node > listsize ){
	    			printf("la posici√≥n no esta en la lista.\n");
	    			node = -1;
	    		}
	    		elseif( node == 1 ){
	    			start = current->next;
	    			free( current );
	    			listsize--;
	    		}
	    		elseif( node != 0 ){
	    			for(int i = 1; i<(node-1); i++){
	    				current = current->next;
	    			}
	    			next = current->next;
	    			current->next = next->next;
	    			free(next);
	    			listsize--;
	    		}
	    
	    		current = start;
	    		printf("La lista contiene los numeros: \n");
	    		while( current ){
	    			printf("%d", current->number);
	    			printf( current->next ? ", " : "\n" );
	    			current =  current->next;
	    		}
	    	} while( node );
	    	
	    	current = start;
	    	while( current ){
	    		next = current->next;
	    		free( current );
	    		current = next;
	    	}
	    return0;
	    }```
	    
	```

* **Lery Andy Pi√©rola Lazarte** (1)

	```
	    #include <stdio.h>
	    #include <stdlib.h>
	    
	    typedef struct Node {
	         int number;
	         struct Node * next;
	    } NODE;
	    
	    NODE * createNode( int number )
	    {
	        NODE * newNode;
	    
	        newNode = malloc( sizeof(NODE));
	        newNode->next = NULL;
	        newNode->number = number;
	    
	        return newNode;
	    }
	    
	    int main( int argc, const char * arg[] )
	    {
	        NODE * start = NULL, * current, * next, * anterior;
	        char goOn;
	        int listSize = 0, number, n_eliminar;
	    
	        do{
	            printf("La lista contiene %d nodos, Ingrese el siguiente n√∫mero (0 para finalizar)\n", listSize);
	            scanf("%d", &number);
	            if( number ){
	                if ( !start ) { 
	                    start = createNode( number );
	                    listSize++;
	                }else{
	                    current = start;
	                    while ( current->next ){
	                        current = current->next;
	                    }
	                    current->next = createNode( number );
	                    listSize++;
	                }
	                goOn = 1;
	              }else{
	                goOn = 0;
	                 // Mostrar lista enlazada   
	                     current = start;
	                     printf("La lista contiene los n√∫meros: \n");
	                     while ( current ){
	                        printf("%d", current->number);
	                        printf( current->next ? ", " : "\n");
	                        current = current->next;
	                     }
	                 //eliminar nodo
	                 printf("Ingrese un numero a eliminar\n");
	                 scanf("%d", &n_eliminar);
	                      current = start;
	                      printf("Buscando numero en los nodos: \n");
	                     while ( current ){
	                        printf("%d\n", current->number);
	                        if ( current->number == n_eliminar )
	                        {
	                             if ( current == start ){//es el primer nodo
	                                start = current->next;
	                             }else{ 
	                                 anterior->next = current->next;
	                             }
	                        }
	    
	                        anterior = current;
	                        current = current->next;
	                     }
	                 
	              }  
	          }while( goOn );
	    
	     // Mostrar lista enlazada   
	        current = start;
	        printf("La lista contiene los n√∫meros: \n");
	        while ( current ){
	            printf("%d", current->number);
	            printf( current->next ? ", " : "\n");
	            current = current->next;
	        }
	    
	     //liberar memoria
	      current = start;
	        while ( current ){
	            next = current->next;
	            free( current );
	            current = next;
	        }
	    
	    
	        return0;
	    }```
	    
	```

* **guillermogranado** (1)

	```
	    #include <stdio.h>
	    #include <stdlib.h>
	    
	    typedef struct Node {
	        int number;
	        struct Node * next;
	    } NODE;
	    
	    NODE * createNode(int number) {
	        NODE * newNode;
	        newNode = malloc(sizeof(NODE));
	        newNode->next = NULL;
	        newNode->number = number;
	        return newNode;
	    }
	    
	    void showLinkedList(NODE * list, int listSize) {
	        printf("The list contains %d numbers. Linked list has this numbers:\n", listSize);
	        NODE * current = list;
	        while (current) {
	            printf("%d", current->number);
	            printf(current->next ? ", " : "\n");
	            current = current->next;
	        }
	    }
	    
	    NODE * removeNodeByNumber(NODE * start, int * listSize, int number) {
	        NODE * nodeToRemove = NULL,
	            * current = start,
	            * prev = NULL;
	        while (!nodeToRemove && current) {
	            if (current->number == number) {
	                nodeToRemove = current;
	                if (prev) {
	                    prev->next = current->next;
	                } else {
	                    start = current->next;
	                }
	            }
	            prev = current;
	            current = current->next;
	        }
	    
	        if (nodeToRemove != NULL) {
	            free(nodeToRemove);
	            *listSize -= 1;
	        }
	        return start;
	    }
	    
	    int main(int argc, const char * argv[]) {
	        NODE * start = NULL, 
	            * current,
	            * next;
	        int goOn, 
	            listSize = 0, 
	            number;
	    
	        do {
	            printf("The list contains %d numbers. Insert new number (0 to finish):\n", listSize);
	            scanf("%d", &number);
	            if (number) {
	                if (!start) {
	                    start = createNode(number);
	                } else {
	                    current = start;
	                    while (current->next) {
	                        current = current->next;
	                    }
	                    current->next = createNode(number);
	                }
	                listSize++;
	                goOn = 1;
	            } else {
	                goOn = 0;
	            }
	        } while(goOn);
	    
	        goOn = 1;
	        int removedResult;
	        do {
	            showLinkedList(start, listSize);
	            printf("Select a number to remove (0 to finish)\n");
	            scanf("%d", &number);
	            if (number == 0) {
	                goOn = 0;
	            } else {
	                start = removeNodeByNumber(start, &listSize, number);
	            }
	    
	            if (listSize == 0) {
	                printf("Linked list is empty\n");
	                goOn = 0;
	            }
	        } while (goOn);
	    
	        current = start;
	        while (current) {
	            next = current->next;
	            free(current);
	            current = next;
	        }    
	    
	        return0;
	    }```
	    
	```

* **Matias Sebastian Perez** (1)

	
	Mi resolucion aqui
	``` 
	    #include <stdio.h>
	    #include <stdlib.h>
	    #include <string.h>
	    
	    /* Las listas enlazadas es una forma de trabajar con arrays que no se encuentran necesariamente es espacios
	       de memoria uno al lado del otro
	    */
	    
	    typedef struct Node{
	        int number; //Contenido del nodo
	        struct Node * next; //Puntero al siguiente nodo
	    } NODE;
	    
	    void printList(NODE * current, char * msg){
	        printf("%s", msg);
	        while(current){
	            printf("%d", current->number); //Printea el contenido del nodo
	            printf(current->next ? ", " : "\n");
	            current = current->next; //Por ultimo asigna al puntero auxiliar el siguiente nodo
	        }
	    }
	    
	    NODE * deleteNode(NODE * to_be_deleted, NODE * previous){
	        NODE * _current;
	    
	        if(previous){
	            previous->next = to_be_deleted->next;
	            _current = to_be_deleted->next;
	            free(to_be_deleted);
	        }else{
	            _current = to_be_deleted->next;
	            free(to_be_deleted);
	        }
	        
	        return _current;
	    }
	    
	    NODE * createNode(int number){ //Funcion que crea un nodo
	        NODE * newNode; //Puntero al nuevo nodo
	    
	        newNode = malloc(sizeof(NODE)); //Malloc devuelve un puntero al espacio en memoria creado
	        newNode->number = number; //Asigna el contenido del key number del nodo
	        newNode->next = NULL; //Es necesario asignar NULL al puntero del siguiente nodo devido a que sino este contenera trash
	    
	        return newNode; //Devuelve la direccion del nodo en memoria
	    }
	    
	    int main(int argc, const char * argv[]){
	        NODE * start = NULL, * current, * next, * previous = NULL; //Crea el puntero al inicio de la cadena y un puntero auxiliar
	        char goOn; //Flag para el while
	        int listSize = 0; //Tamano total de la cadena (No se usa mucho)
	        int number; //Numero ingresado por el usuario
	    
	        do{
	            printf("La lista contiene %d nodos. Ingrese el siguiente numero (0 para finalizar): ", listSize);
	            scanf("%d", &number); //Ingreso de numero
	            if(number){ //Si el numero es distinto de 0
	                if(!start){ //Si es el unico nodo existente
	                    start = createNode(number); //Crea el primer nodo y asina la direccion al puntero start
	                    listSize++;
	                }else{
	                    current = start; //Asigna el puntero auxiliar a la posicion inicial de la cadena
	                    while( current -> next ){ //Mientras el puntero auxiliar al nodo encuentre que el nodo tiene un siguiente
	                        current = current->next; //Asigno la posicion del siguiente nodo al puntero auxiliar
	                    }// El sentido de este while es moverme hacia el final de la cadena
	                    current->next = createNode(number); //Una vez en el final, creo un nuevo nodo
	                    listSize++;
	                }
	                goOn = 1;
	            }else{
	                goOn = 0;
	            }
	        }while(goOn);
	    
	        printList(start, "La lista es: "); //Asigna el puntero auxiliar al inicio del array
	    
	        printf("Ahora ingrese el numero que quiere eliminar de los nodos: ");
	        scanf("%d", &number);
	        current = start;
	        while(current){
	            if(number == current->number){
	                current = deleteNode(current, previous);
	                if(!previous){
	                    start = current;
	                }
	                listSize--;
	            }else{
	                previous = current;
	                current = current->next;
	            }
	        }
	    
	        printList(start, "Luego del borrado la lista es: ");
	    
	        //Cleaning memory
	        current = start;
	        while(current){
	            next = current -> next; //Necesitamos el auxiliar de next porque en la siguiente linea borramos el current
	            free(current); //Limpiando current
	            current = next; //Asignando next a current para el siguiente ciclo
	        }
	    
	        return0;
	    }
	    
	```

# Usos pr√°cticos

## 0270. C√°lculos complejos

### Descripci√≥n:


### Links:

* [platzi_curso_c_clases/pitagoras.c at 20f165ae9d6c94401d94241b51763aba47b71ad0 ¬∑ mchojrin/platzi_curso_c_clases ¬∑ GitHub](https://github.com/mchojrin/platzi_curso_c_clases/blob/20f165ae9d6c94401d94241b51763aba47b71ad0/pitagoras.c)

* [platzi_curso_c_clases/next_date.c at d716498b51fe4dfec6b0e06521c26f0214aa3e21 ¬∑ mchojrin/platzi_curso_c_clases ¬∑ GitHub](https://github.com/mchojrin/platzi_curso_c_clases/blob/d716498b51fe4dfec6b0e06521c26f0214aa3e21/next_date.c)

* [platzi_curso_c_clases/random.c at d716498b51fe4dfec6b0e06521c26f0214aa3e21 ¬∑ mchojrin/platzi_curso_c_clases ¬∑ GitHub](https://github.com/mchojrin/platzi_curso_c_clases/blob/d716498b51fe4dfec6b0e06521c26f0214aa3e21/random.c)

### Comentarios:

* **Alejandro Urrea Giraldo** (1)

	
	Una aplicaci√≥n simple de los n√∫meros aleatorios y la fucni√≥n **rand()** : Un dado!
	``` 
	    #include <stdio.h>
	    #include <stdlib.h>
	    #include <string.h>
	    #include <time.h>
	    
	    int main (int argc, const char *argv[]){
	    
	      srand(time(NULL));
	      char input[2];
	      int result=0;
	    
	      while(strcmp(input,"x")!=0){
	        printf("Ingrese cualquier caracter para lanzar los dados(x para terminar): ");
	        scanf("%s",input);
	        if (strcmp(input,"x")==0){return1;}
	        result=(rand()%6)+1;
	    
	        switch (result){
	          case1:
	          printf(" -------\n");
	          printf("|       |\n");
	          printf("|   *   |\n");
	          printf("|       |\n");
	          printf(" ¬Ø¬Ø¬Ø¬Ø¬Ø¬Ø¬Ø\n");
	          break;
	    
	          case2:
	          printf(" -------\n");
	          printf("| *     |\n");
	          printf("|       |\n");
	          printf("|     * |\n");
	          printf(" ¬Ø¬Ø¬Ø¬Ø¬Ø¬Ø¬Ø\n");
	          break;
	    
	          case3:
	          printf(" -------\n");
	          printf("| *     |\n");
	          printf("|   *   |\n");
	          printf("|     * |\n");
	          printf(" ¬Ø¬Ø¬Ø¬Ø¬Ø¬Ø¬Ø\n");
	          break;
	    
	          case4:
	          printf(" -------\n");
	          printf("| *   * |\n");
	          printf("|       |\n");
	          printf("| *   * |\n");
	          printf(" ¬Ø¬Ø¬Ø¬Ø¬Ø¬Ø¬Ø\n");
	          break;
	    
	          case5:
	          printf(" -------\n");
	          printf("| *   * |\n");
	          printf("|   *   |\n");
	          printf("| *   * |\n");
	          printf(" ¬Ø¬Ø¬Ø¬Ø¬Ø¬Ø¬Ø\n");
	          break;
	    
	          case6:
	          printf(" -------\n");
	          printf("| *   * |\n");
	          printf("| *   * |\n");
	          printf("| *   * |\n");
	          printf(" ¬Ø¬Ø¬Ø¬Ø¬Ø¬Ø¬Ø\n");
	          break;
	    
	        }
	      }
	    
	      return0;
	    }
	    
	```
	
	![dice_exe.png](https://static.platzi.com/media/user_upload/dice_exe-68e6e295-ecc3-454a-9fff-3b95aada9ccf.jpg)

* **Luis_Cruz_Cruz** (1)

	
	Aqui hace un comentario legendario... "Te invito a que hagas el calculo si no le crees, yo le voy a creer" Mauro Chojrin.

* **ffranco_** (1)

	
	La aclaraci√≥n que encontr√© en <http://www.cplusplus.com/reference/ctime/time_t/> es que time_t NO es una esctructura, sino un typedef que viene incluido en la librer√≠a time.h

## 0280. Manejo de archivos de texto

### Descripci√≥n:


### Links:

* [platzi_curso_c_clases/writefile.c at master ¬∑ mchojrin/platzi_curso_c_clases ¬∑ GitHub](https://github.com/mchojrin/platzi_curso_c_clases/blob/master/writefile.c)

### Comentarios:

* **Alan86** (3)

	
	Estar√≠a bueno que comentar√°n tambi√©n acerca de la funci√≥n fflush, para los casos en el que la funci√≥n scanf toma como car√°cter el enter

* **Luis_Cruz_Cruz** (1)

	
	Hola a todos.
	
	Solo por curiosidad. Este es el mensaje de error cuando no tienes privilegios de lectura en el archivo.
	
	![Error_read.jpg](https://static.platzi.com/media/user_upload/Error_read-75e79364-a368-447a-ad4a-db951f9e1084.jpg)

* **Juan Fernando Romero Ortega** (1)

	```
	    #include<stdio.h>
	    #include<stdlib.h>
	    
	    intmain(int argc, constchar * argv[]){
	        FILE * fb = fopen(argv[1], "r");
	        char c;
	    
	        while((c = fgetc(fb) != EOF)){
	            printf("%c", c);
	        }
	    
	        fclose(fb);
	    
	        return0;
	    }```
	    
	```

	* **Mario E Fernandez  Serrano** (1)

		
		Hola, revisa el par√©ntesis de la repetitiva:
		``` 
		    while ((c = fgetc(fb) != EOF) ) {
		            printf("%c", c);
		        }
		    
		```
		
		Deber√≠as ser as√≠.
		``` 
		    #include<stdio.h>
		    #include<stdlib.h>
		    
		    intmain(int argc, constchar * argv[]){
		    FILE * fb = fopen(argv[1], ‚Äúr‚Äù);
		    char c;
		    
		    while( (c = fgetc (fb) ) != EOF) {
		        printf("%c", c);
		    }
		    
		    fclose(fb);
		    
		    return0;
		    }
		    
		```

* **Juan Fernando Romero Ortega** (1)

	
	Saludos, me ocurre lo siguiente al leer un archivo, me aparecen caracteres de esta manera:
	``` 
	    D:\Curso Introduccion C>readFile readFile.c
	    ????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????```
	    
	```

* **ffranco_** (1)
¬øPor qu√© el modo es una cadena ‚Äúr‚Äù o ‚Äúw‚Äù , osea va entre comillas dobles, si realmente es un caracter y deber√≠a ir entre comillas simples?

	* **Luis Fernando Zarazua Aguilar** (1)

		
		Porque el tipo de dato que pide es un char *, con lo cual entiende que por defecto necesita una cadena.  
		![TipoDato.png](https://static.platzi.com/media/user_upload/TipoDato-777ea031-86af-46f7-a3cb-0d0253c4efb8.jpg)

* **jimezam** (1)
¬øHay alguna ventaja en mezclar el uso de las funciones fprintf/fscanf con las de fputs/fgets en lugar de ser cobsistente con una sola de...

	* **Erik Ochoa (Platzi)** (3)

		
		No son intercambiables entre s√≠, por ejemplo:
		
		  * **fprintf** : permite dar formato a la salida en diferentes tipos.
		
		  * **fputs** : simplemente escribe el string de entrada como salida al ‚Äúoutput stream‚Äù indicado.
		
		
		
		
		Te recomiendo leer la documentaci√≥n oficial.
		
		  * <http://www.cplusplus.com/reference/cstdio/fprintf/>
		  * <http://www.cplusplus.com/reference/cstdio/fputs/>
		
		

## 0290. Manejo de archivos binarios

### Descripci√≥n:


### Comentarios:

* **Francisco Sebastian Due√±as Caicedo** (3)

	
	¬øEs posible guardar una estructura la cual tenga un puntero en un archivo binario?

	* **Mauro Chojrin** (4)

		
		Es posible aunque no creo que sea muy recomendable. Ten en cuenta que el valor que tiene un puntero en un determinado momento surge del estado general de la memoria al momento de ejecutar el programa.  
		Si almacenas un puntero, nada te garantiza que al leerlo el contenido de la posici√≥n de memoria a la que apuntaba al momento de escribirse siga siendo v√°lido‚Ä¶
		
		Puede pasarte lo mismo que se ve en [https://platzi.com/clases/1740-lenguaje-c/24214-aritmetica-de-punteros/?time=270](url)

## 0300. Paralelismo

### Descripci√≥n:


### Comentarios:

* **skorpion** (2)

	
	En el proceso padre luego del wait no se esta imprimiendo el valor de shared, se esta imprimendo el valor de 1 directamente.

* **Johan Lisandro Castiblanco** (1)

	
	Luke I am your fatheeer noooo, wtf process noooo ‚Ä¶ re buena manera de entender me gustoo

* **Jean Carlos Nu√±ez Hernandez** (1)

	
	Es importante entender el paralelismo sirve mucho para trabajar con sockets

* **Walter Barrios Vazquez** (1)

	
	Hola profe, estoy usando codeBlocks y Dev-C++ con el compilador gcc para probar el c√≥digo y en ambos casos la librer√≠a <sys/wait.h> no se encuentra.  
	Saludos tambi√©n a quienes est√©n cursando y preguntarles si les pas√≥ lo mismo en ese caso ¬øc√≥mo lo solucionaron?  
	Gracias.

	* **Walter Barrios Vazquez** (1)

		
		¬øSe puede agregar manualmente una librer√≠a est√°ndar en C como la sys/wait.h o wait.h? ¬øSon la misma librer√≠a y en <sys/wait.h> estamos indicando que wait.h est√° dentro de la carpeta sys?

	* **Mauro Chojrin** (1)

		
		Hay que ver c√≥mo est√° la configuraci√≥n de tu entorno‚Ä¶ especialmente ¬øest√°s usando Linux, Windows, Mac‚Ä¶?

	* **Walter Barrios Vazquez** (1)

		
		Estoy usando Windows.

* **Franco Bottazzi** (1)
Despu√©s, podr√≠as explicar la sintaxis del ciclo while con el while al final y sin corchetes? ¬øY por qu√© se necesita un while pero si se u...

* **Franco Bottazzi** (1)
Una duda. En 3:20 dec√≠s que si fork() retorn√≥ 0, estoy en el proceso hijo, pero cuando imprim√≠s muestra que fork retorn√≥ 405 ¬øC√≥mo ser√≠a ...

* **Manea luca cristian** (1)
me dice que no encuentra la libreria sys/type.h como podria a√±adirla manualmente?

# Comunicaci√≥n entre procesos

## 0310. Pipes

### Descripci√≥n:


### Comentarios:

* **andres-felipe-aguirre-fajardo** (3)

	
	no se puede hace comunicaci√≥n entre procesos con apuntadores?, ya que a pesar de que se hagan copias de las variables en el otro proceso si los apuntadores apuntan al mismo espacio de memoria, no se podr√≠a compartir informaci√≥n?

	* **Mauro Chojrin** (4)

		
		En teor√≠a se podr√≠a, pero depende del sistema operativo. Existen algunos S.O. que ‚Äúmuestran‚Äù a cada proceso un espacio de memoria independiente de los dem√°s‚Ä¶ en ese caso no ser√° posible hacer lo que sugieres.

* **guillermogranado** (2)
Al hacer el ejemplo el resultando en mi terminal no es el mismo que aparece en video. Primero muestra todos los pasos del padre y despu√©s...

* **Federico Badiola** (1)

	
	Hola Mauro,  
	Lo primero de todo, muy bien explicado.  
	Me ha surgido alguna duda mientras ve√≠a los videos de pipes y de sockets y he vuelto hacia atr√°s para escribirlas y que me pueda dar su respuesta y opini√≥n al respecto.
	
	  * ¬øPor qu√© hacer un fork al proceso y no levantar threads? Si no tengo entendido mal, el coste de levantar un proceso es mayor que levantar un thread. A dem√°s al tener memoria compartida la comunicaci√≥n se puede hacer directamente a trav√©s de la memoria. Aunque tambi√©n se podr√≠a hacer un mmap y que compartan memoria los dos procesos pero, IMHO creo que es menos llamativo, ¬øqu√© opinas?
	
	  * ¬øLos pipes sobre FS son ampliamente utilizados? ¬øO soluciones como Signal o memoria compartida son m√°s habituales en sistemas complejos o en producci√≥n? El contexto de mi pregunta es: la latencia de ir a disco o a red es muy superior a la memoria, se me hace extra√±o que en situaciones complejas se usen estos sistemas. Si bien es cierto que en sistemas con memorias muy limitadas y con capacidad de disco es buena manera para encolar mensajes arbitrariamente pesados.
	
	
	
	
	Muchas gracias por la atenci√≥n!!

* **Cristian Rosales** (1)

	
	[Aqu√≠](https://www.driverlandia.com/programacion-c-avanzada-forks-pipes-y-como-comunicar-programa-padre-con-hijo/) pueden conseguir otro ejemplo si no qued√≥ del todo claro‚úåüèº

* **EPadronU23** (1)

	
	Mi intento via un muy simple `cat`
	``` 
	    /* Libraries ********************************************************/
	    #include <stdio.h>
	    #include <stdlib.h>
	    #include <string.h>
	    #include <unistd.h>
	    #include <wait.h>
	    /********************************************************************/
	    
	    /* Constants ********************************************************/
	    #define BUFFER_SIZE 100
	    
	    #define NO_FILE_ERROR -1
	    
	    #define FILE_OPEN_ERROR -2
	    /********************************************************************/
	    
	    /* Types ************************************************************/
	    typedef int IN_OUT_PIPE_DESCRIPTOR[2];
	    
	    typedef int PID;
	    /********************************************************************/
	    
	    /* Functions ********************************************************/
	    int parent(IN_OUT_PIPE_DESCRIPTOR inOutPipe, char* filePath) {
	      FILE* fp;
	    
	      if (!(fp = fopen(filePath, "r"))) {
	        return FILE_OPEN_ERROR;
	      }
	    
	      for(char buffer[BUFFER_SIZE]; !feof(fp); fgets(buffer, BUFFER_SIZE, fp)) {
	        write(inOutPipe[1], buffer, BUFFER_SIZE);
	      }
	    
	      close(inOutPipe[1]);
	    
	      wait(NULL);
	    
	      return 0;
	    }
	    
	    int child(IN_OUT_PIPE_DESCRIPTOR inOutPipe) {
	      close(inOutPipe[1]);
	    
	      char buffer[BUFFER_SIZE];
	    
	      while (read(inOutPipe[0], buffer, BUFFER_SIZE)) {
	        fputs("> ", stdout);
	        fputs(buffer, stdout);
	    
	        if (strchr(buffer, '\n') == NULL) {
	          fputs("\n", stdout);
	        }
	      }
	    
	      return 0;
	    }
	    /********************************************************************/
	    
	    /* Main *************************************************************/
	    int main(int argc, char* argv[]) {
	      if (argc < 2) {
	        fputs("No file was supplied\n", stderr);
	    
	        return NO_FILE_ERROR;
	      }
	    
	      IN_OUT_PIPE_DESCRIPTOR inOutPipe;
	    
	      pipe(inOutPipe);
	    
	      if (fork()) {
	        return parent(inOutPipe, argv[1]);
	      } else {
	        return child(inOutPipe);
	      }
	    
	      return 0;
	    }
	    /********************************************************************/
	    
	```

## 0320. Sockets

### Descripci√≥n:


### Comentarios:

* **Cristian Rosales** (2)

	
	Socketsü§òüèº

* **Jean Carlos Nu√±ez Hernandez** (2)

	
	Sockets son comunicacion punto a punto bidireccional

* **Abdel Mejia** (2)

	
	ü§Ø Genial

* **Lery Andy Pi√©rola Lazarte** (1)

	
	Tengo un problema, uso win8 y no puedo ubicar las librerias que se necesitan. Instale codeblocks como se pidio a un principio üò¶ desde Paralelismo no me compila debido a ese tema.

	* **Nicolas David Pastran Zamora** (1)

		
		Te recomiendo instalar la terminal de Ubuntu esta en la tienda de Windows.

* **Jean Carlos Nu√±ez Hernandez** (1)

	
	Sockts no permite comunicar dos procesos cualquiera

* **Manuel Fernando Ni√±o Ria√±o** (1)
para iot en tiempo real es mejor sockets o API rest?

	* **AnthonySQC** (2)

		
		Hola Manuel,  
		las comunicaciones en tiempo real generalmente son un escenario indicado para el uso de sockets, te dejo un blog en el que se realiza una comparativa de ambos:  
		[](https://www.educba.com/websocket-vs-rest/)  
		En stackoverflow tambien han tratado el tema:  
		[](https://stackoverflow.com/questions/28613399/websocket-vs-rest-api-for-real-time-data)  
		Espero que te ayude y un saludo.

## 0330. Sockets C√≥digo del servidor

### Descripci√≥n:


### Comentarios:

## 0340. Sockets c√≥digo de cliente

### Descripci√≥n:


### Comentarios:

## 0350. Comunicaci√≥n v√≠a sockets ejecuci√≥n

### Descripci√≥n:


### Comentarios:

* **David Felipe Boh√≥rquez** (3)

	
	Todo me funcion√≥ perfecto. Est√° genial. Voy a intentarlo con m√°quinas remotas.
	
	Por cierto, ese comando de vim est√° genial! Platzi deber√≠a considerar hacer un curso de vim, es un editor muuy completo üòÆ

	* **Mario E Fernandez  Serrano** (1)

		
		[La documentaci√≥n ayudarte](https://www.vim.org/docs.php)
		
		[Guia-vim.PDF ](http://es.tldp.org/Tutoriales/doc-tutorial-vim/Guia-Vim.pdf)

* **Juan Fernando Romero Ortega** (1)

	
	Saludos,
	
	Muchas gracias por el curso. Respecto al modulo de comunicaci√≥n entre procesos, en windows 10 falta explicaci√≥n sobre algunos archivo que se deben instalar, pues las librerias de sockets no las encuentra el programa, y esto hace que falle la compilaci√≥n

# Conclusiones

## 0360. Conclusiones

### Descripci√≥n:


### Links:

* [Internet of Things](https://platzi.com/learning-path/iot/)

* [GitHub - mysql/mysql-server: MySQL Server, the world's most popular open source database, and MySQL Cluster, a real-time, open source transactional database.](https://github.com/mysql/mysql-server)

* [GitHub - php/php-src: The PHP Interpreter](https://github.com/php/php-src)

* [GitHub - torvalds/linux: Linux kernel source tree](https://github.com/torvalds/linux)

### Comentarios:

* **Sebastian Augusto Baez Ramos** (4)

	
	Ojal√° pudiera continuar aprendiendo C++ con el mismo profesor y aclarar si todo lo aprendido en este curso seguir√° siendo pr√°ctico.

* **Juan Issaias Asencio Rivero** (1)

	
	Muchas gracias Mauro, ¬°aprendi mucho en este curso.!

* **Cristian Rosales** (1)

	
	Muchas gracias Mauro, excelente cursoüëç

* **David Felipe Boh√≥rquez** (1)

	
	Aprend√≠ bastante en el curso, excelente profesor. Gracias!

